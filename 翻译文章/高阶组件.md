[原文地址](https://facebook.github.io/react/docs/higher-order-components.html)
# 高阶组件
高阶组件（HOC）是react中组件复用的高级技巧。HOC不是reactapi的一部分。它们是从react中自然而然出现的一种开发模式。
具体来讲，*高阶组件就是一个获取组件并返回新组件的函数*。

    const EnhancedComponent = higherOrderComponent(WrappedComponent);
虽然组件从props转化成UI，一个高阶组件是从一个组件转变成另一个组件。
# 使用高阶组件解决横切关注点问题

    译者注：横切关键点指的是软件开发中，具有横跨多个模块的行为。比如日志，安全和数据转换在整个项目中都有使用，这样就容易造成耦合和模块化的丧失。
>注意
>我们之前建议使用mixin来解决横切关注点问题。后来我们意识到mixins造成的麻烦比他带来的收益要打。[读这里](https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html)了解为什么我们移除了mixin并且怎么转换你现在使用的mixin代码

组件是react中代码复用的最小单元。然而，你会发现有些模式下不能直接使用传统的组件。

举个例子，你有一个`CommentList`组件订阅了一个外部数据源来渲染评论列表：

    class CommentList extends React.Component {
    constructor() {
        super();
        this.handleChange = this.handleChange.bind(this);
        this.state = {
        // "DataSource" 是全局数据源
        comments: DataSource.getComments()
        };
    }

    componentDidMount() {
        // 订阅一个数据改变时候的回调函数
        DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
        // 移除订阅的回调
        DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
        // 在数据源改变的时候更新组件
        this.setState({
            comments: DataSource.getComments()
        });
    }

    render() {
        return (
            <div>
                {this.state.comments.map((comment) => (
                <Comment comment={comment} key={comment.id} />
                ))}
            </div>
            );
        }
    }

不久后，你写了一个组件用于显示订阅的某一个博客文章。和之前的模式很像：

    class BlogPost extends React.Component {
    constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.state = {
        blogPost: DataSource.getBlogPost(props.id)
        };
    }

    componentDidMount() {
        DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
        DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
        this.setState({
            blogPost: DataSource.getBlogPost(this.props.id)
        });
    }

    render() {
        return <TextBlock text={this.state.blogPost} />;
    }
    }

`CommentList`和`BlogPost`不是一模一样-他们在`DataSource`上调用不同的方法并且渲染的结果也不同。但是他们大部分的实现是一样的：
* 在react渲染出UI的时候给`DataSource`增加一个监听
* 当数据变化时候，在监听内部调用`setState`
* 在销毁页面dom时候，去除监听

你可以想象在一个大的app中，同样的订阅`DataSource`并且调用`setState`的模式会有很多。我们想要一个抽象的方式允许我们在某个单独的地方定义这个逻辑并且能和其他的模块共享。这就是高阶组件擅长的。

我们来写一个创建函数的组件，类似`CommentList`和`BlogPost`，订阅`DataSource`。这个函数会从接收的参数中的一个作为一个子组件，这个子组件接收订阅的数据作为props。我们把这个函数命名为`withSubscription` :

    const CommentListWithSubscription = withSubscription(
        CommentList,
        (DataSource) => DataSource.getComments()
    );

    const BlogPostWithSubscription = withSubscription(
        BlogPost,
        (DataSource, props) => DataSource.getBlogPost(props.id)
    );

第一个参数是包装组件。第二个参数函数用来获取我们需要的数据，设置DataSource和当前的props作为函数参数。

当`CommentListWithSubscription`和`BlogPostWithSubscription `渲染的时候，`CommentList`和`BlogPost`将会把最新从`DataSource`获取的数据命名为data传递个prop。

    // 这个函数使用一个组件
    function withSubscription(WrappedComponent, selectData) {
        // 返回一个组件
        return class extends React.Component {
            constructor(props) {
                super(props);
                this.handleChange = this.handleChange.bind(this);
                this.state = {
                    data: selectData(DataSource, props)
                };
            }

            componentDidMount() {
                // 处理订阅
                DataSource.addChangeListener(this.handleChange);
            }

            componentWillUnmount() {
                DataSource.removeChangeListener(this.handleChange);
            }

            handleChange() {
                this.setState({
                    data: selectData(DataSource, this.props)
                });
            }

            render() {
                // 使用最新的数据渲染包装的组件。
                // 注意我们还把当前组件的所有props属性都传递给了包装组件
                return <WrappedComponent data={this.state.data} {...this.props} />;
            }
        };
    }

    译者理解：输入一个组件，一个公共的处理方法。输出组件是包装后的输入组件。输出组件中归纳了某种共同的逻辑，比如componentDidMount和componentWillUmount中定义了一些公共逻辑。执行输入的公共处理方法。然后把公共处理方法输出的数据和这个包装后的组件传入的props都作为参数传递给输入组件。

注意HOC不改变输入的组件，也不实用继承来复制行为。HOC通过把输入的组件包装成一个容器组件的方式来组合原始的组件。HOC是一个没有副作用的纯函数。

被包装的组件从它的容器组件那里获取所有props属性作为它自己的props属性。然后设置自己props中的`data`属性用来渲染输出。HOC不关心怎么样或者为什么这个data被使用，并且这个被包装的组件不关心data是从哪儿获得的。

因为`withSubscription`是一个不同方法，你可以添加任意的参数随你喜欢。比如你可能想要`data`prop属性是可配置的，以进一步隔离HOC和被包装的组件。或者你可以接收一个参数配置`shouldComponentUpdate`或者数据源等。这些都可以实现因为HOC可以随你怎么定制返回的包装组件。

像一般组件一样，`withSubscription`和被包装组件之前的联系是基于props的。因此很容易从一个HOC转变成另一个，只要他们提供一样的props给被包装的组件。这会很方便，如果你要改变数据获取库之类的。（译者注：因为这相当于遵循了d，依赖倒置原则，即被包装组件不依赖数据获取库，而库和被包装组件也没有依赖，都依赖于高阶组件的组合和控制）

# 不要改变原始组件。使用组合
抵御想要在HOC中改变组件原型或者改变内部结构的冲动。

    function logProps(InputComponent) {
        InputComponent.prototype.componentWillReceiveProps(nextProps) {
            console.log('Current props: ', this.props);
            console.log('Next props: ', nextProps);
        }
        //实际上我们返回的原始输入已经被改变了
        return InputComponent;
    }

    // 这样的话无论传进去什么props，都会打印log（拓展性差了）
    const EnhancedComponent = logProps(InputComponent);

有好几个问题。第一是input组件不能离开`EnhancedComponent`单独复用。更重要的四。如果你使用另一个HOC也调用input的话，并且也改变componentWillReceiveProps的话，第一个HOC也变了。

不要改变内部，HOC应该使用组合。通过包装input组件在一个包装组件里。

    function logProps(WrappedComponent) {
        return class extends React.Component {
            componentWillReceiveProps(nextProps) {
                console.log('Current props: ', this.props);
                console.log('Next props: ', nextProps);
            }
            render() {
                // 把组件包装在一个容器组件里，不要改变输入组件，而是在包装组件里控制。
                return <WrappedComponent {...this.props} />;
            }
        }
    }

这样实现了功能还避免了潜在的冲突。因为HOC是纯函数，还可以和其他HOC组合，甚至和自己组合。

HOC和一种叫做`container componets`的模式很类似。容器组件是在高级关注和低级关注之间分割责任的策略的一部分。容易管理诸如订阅，状态，并传递props给被包装的容器来处理事务-比如真正的渲染。（本人做的一个项目实践是把权限统一控制在一个模块中，然后在不同的模块中调用权限模块的方法，分发权限，然后根据获得的权限每个具体事务模块再进行处理，好像耦合度比较高）。HOC使用容器作为实现方式（实现管理，控制）。你可以认为HOC定义为参数化的容器组件。

# HOC约定：只传递和当前关注的具体内容无关的props给被包装组件

HOC给组件添加功能但是不应该剧烈的改变返回的组件和被包装组件之间的联系。期待通过HOC返回的组件和被包装的组件有相似的接口。

HOC传递的props应该和它当前具体的内容不相关。（就是说HOC的参数无论定义命名，还是表现都应该和当前的具体实现无关，更泛用，更易复用）。大多数的HOC返回组件的render方法应该像下面一样：

    render() {
        // 过滤出具体到当前hoc的额外props并且不应该传递到被包装组件中
        // Filter out extra props that are specific to this HOC and shouldn't be
        // passed through
        const { extraProp, ...passThroughProps } = this.props;

        // 需要注入被包装组件的props。这些一般是state值或者实例的方法。
        // Inject props into the wrapped component. These are usually state values or
        // instance methods.
        const injectedProp = someStateOrInstanceMethod;

        // 传递props给被包装组件
        // Pass props to wrapped component
        return (
            <WrappedComponent
            injectedProp={injectedProp}
            {...passThroughProps}
            />
        );
    }


    译者注：就是传进来的pros要筛选成3份：
    1. extraProp 具体到当前HOC逻辑的
    2. passThrouProps 可以传递到被包装组件的
    3. injectProp 子组件实际使用的

# 约定：最大化可组合性
