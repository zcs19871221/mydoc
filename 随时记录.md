# href="#" vs href="javascript:void(0)"(或者href="javascript:;")

# bowlder的问题之一：
3768行，removeChild之后，会导致有滑动的页面，滑动条位置由于删掉了dom而到了原位置的上部分，如果这时候有新的dom插入，位置就会有问题。（过多的页面bind真的好吗？那么多的回调函数句柄)

# debounce的再次学习
  debounce用于防止短时间内重复执行函数太多次，目的是指定一个时间wait，让函数的真正执行至少在wait秒之后，期间如果连续触发函数，那么函数的真正执行在最后一次触发的wait秒之后。
  当第一次触发的时候，设置timeout到wait秒以后执行later函数。然后再触发的时候，只要timeout非空（没开始执行），只记录触发的时间，不再处理。
  later函数会判断现在时间减去最近一次触发debounce的时间，如果小于指定的延迟，那么再次延迟wait-last的时间执行。
# throttle
 触发函数后，每隔wait秒执行一次，如果中间多次触发，不响应。

# 关于tabindex和键盘事件
https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets

# 关于js中的数字计算问题，一定要注意，js的计算是有小数点的，没有整数，注意处理

# 关于正则正向肯定查找?=
    用于匹配zcs?=asd仅当zcs后面跟着asd才匹配

# 关于new Function()的妙用
    通过传参数可以把参数写入到函数体中，这样有些表达式可以不通过eval而是写成函数体。
    function genFunc(expr) {
        return new Function('obj', 'with(obj)return ' + expr);
    }
首先可以通过表达式的结果动态的创建函数，而且可以传参数。

# 关于正则的逻辑|
    使用时候最好在需要或的地方加()，否则范围不定：
    /^abc|123$/ 对应实际是：

    /^ab(c|123)$/
    /^ab(c|12)3$/
    /^ab(c|1)23$/
    /^a(bc|1)23$/
    /^a(bc|12)3$/
    /^a(bc|123)$/
    /^(abc)|(1)23$/
    /^(abc)|(12)3$/
# content-type
 标识内容的mime-type
 请求头用来标识Post,put请求的formdata类型
 响应头用来标识返回内容的类型

# 关于http请求的请求体
[详见overstack回答](http://stackoverflow.com/questions/16339198/which-http-methods-require-a-body#answer-16339271)
    一般来说，除了trace请求，head,1xx,204,304返回外，其他的都可以有请求体。

    an entity-body is explicitly forbidden in TRACE requests only, all other request types are unrestricted (section 9, and 9.8 specifically)

    a message-body is explicitly forbidden in responses to HEAD requests (section 9, and 9.4 specifically)
    a message-body is explicitly forbidden in 1xx (informational), 204 (no content), and 304 (not modified) responses (section 4.3)

# 关于Number的toString方法  进制转换
    Number.toString()是数字转换成字符串的方法，接受一个参数，用来表示转换的进制。默认是10。
    如果(35).toString(36) = z;

#关于textContent
node接口的一个属性,用于获取或设置这个dom的文本.
注意用法:
node.textContent = "";
当设置textContent值的时候,这个节点的所有childNodes都被移除,替换成一个包含字符串的文本节点

# 关于bowlder中的defer
    每个defer自己的闭包的变量有:
        value: 当前defer运行的结果,通过def函数包装成含有then方法的对象.
        pending: 下一个defer包装好的待执行的回调函数列表.如果本defer结束运行,pending置为undefined.回调函数是:defer-next.resolve(realcallback(realvalue)) 来让链式调用往下走.


    resolve方法: 包裹真正的value到本defer的value,然后根据是否有pending,执行value.then(pending);value.then就是defer-next.resolve(callback(value)).然后defer-next又会查看是否有pending.决定是否调用下一个value.then
    

    then方法:新建一个defer并返回.
    包裹一个回调函数wrapcb: newdefer.resolve(callback(value)).保存传进来的真正的回调函数
    然后根据上一个promise的完成情况,决定是立刻执行:value.then(wrapcb)还是pending.push(wrapcb).

    def方法:当resolve触发的时候,包裹真正的value值变成一个promise:
          return {
            then: function(callback) {
              // // var result = defer();
              // // result.resolve(callback(value));
              // return result.promise;
              callback(value);
            }
          };
          其实这里这么写的主要用意是让ref("1233").then().then(),否则的话直接
          callback(value)也可以.触发:wrapback(value)=>defernext.resolve(realcb(realvalue))

          通过不停的创造defer,把下一个defer的回调放到本defer里,来实现链式的调用.
# bowlder中load如果带@的处理
  会把父亲组件的路径去掉文件,然后加上@后头路径

# 正则-exec和test使用全局标识匹配的问题
同一个使用全局标识的正则连续匹配会出现不正确匹配:因为lastIndex每次匹配都会变化,设置为匹配的最终位置下次匹配从lastIndex位置开始

    var reg = /test/g;
    console.log(reg.test("这是1个test"));
    console.log(reg.lastIndex);
    console.log(reg.test("test不错啊啊啊"));

# chrome debug快捷键

    触发断点效果: ctrl + F8
    下一个断点: F8
    跳到下一个调用栈: ctrl + ,
    返回上一个调用栈: ctrl + .
    在控制台中执行: Ctrl + Shift + E
    增加断点: ctrl + B

# 获得相对位置的方法:element.getBoundingClientRect
  
# canvas操作像素
    ImageData
    https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas

#元素相对位置
## 视窗位置:浏览器可见位置,不包含滚动条.
## element.getBoundingClientRect 
    获取相对于视窗(就是浏览器左上角的位置),这个位置是动态计算的,包含这个元素内层的滚动,但是
    不包含整个浏览器的滚动条的位置,如果要计算相对于页面内容左上角的位置,需要加上
    window.pageYOffset和window.pageXOffset 
    https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect
![](getBoundingClientRect.jpg)

## offsetLeft, offsetParent 
相对于offsetParent的偏移位置
offsetParent是一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table 元素对象或根元素（标准模式下为 html；quirks 模式下为 body）。
所以对于中间的元素来说,如果有滚动条的话,随着滚动,元素的位置会上下,左右移动,因此还应该把所有父元素(除去body或window)的滚动条移动距离加上或减去.

    function getPos(e) {
        var left = 0,
            top = 0,
            scrollLeft = 0,
            scrollTop = 0,
            b = e.parentNode;
        while (e) {
          left = left + e.offsetLeft;
          top = top + e.offsetTop;
          e = e.offsetParent;
        }
        while (b && (b.nodeName.toLowerCase() !== "body")) {
          scrollLeft = scrollLeft + (b.scrollLeft||0);
          scrollTop = scrollTop + (b.scrollTop || 0);
          b = b.parentNode;
        }
        return {
          left: left - scrollLeft,
          top: top - scrollTop
        }
    }
## 关于图片加载完成的回调函数
 先看正确的例子:
 var img = new Image();
 img.onload = function() {
    img.onload = null;
    callback();
 }
 img.src = url;

几个点:
  1.回调函数中不要引用img,会造成低版本的IE无法回收内存(自己引用自己),所以执行的时候如果设置回调函数为null,一方面保证内存不会泄漏,第二方面防止GIF图重复触发onload事件
  2.为什么src要放到onload后头,因为如果有缓存的图片,刚设置src可能瞬间就要触发onload,这时候有的浏览器onload事件还没有设置,所以先设置onload
  3.不要使用complete属性
  4.无论是否有缓存,加载完成都会触发onload事件

  # v8的设计架构
  https://github.com/v8/v8/wiki/Design%20Elements
  http://blog.pluskid.org/?p=186

js为什么慢?因为它是动态语言,每次访问一个对象的时候,都得动态的查找它的位置,
而想java或c,每一个对象的偏移位置都是确定的,根据编译时候它们固定的类结构,,因此一次查找就是一个取偏移值的过程,很快.
1.v8的目标就是内部实现隐藏的类,新建对象创建一个隐藏类,每个属性创建一个,指定属性的偏移值.
2.v8的垃圾回收快:
  1.垃圾回收时候会暂停程序
  2.只暂停部分的内存空间
  3.每个对象都有指针

# 不能冒泡的js事件
    submit, focus, blur, load, unload, change, reset, scroll, most of the DOM events (DOMFocusIn, DOMFocusOut, DOMNodeRemoved, etc), mouseenter, mouseleave, etc

# 关于动态加载html的若干注意
1. html中的`<style>`和`<link>`处理   
  先放到head中,等加载完成后,再把html append到页面上防止页面二次渲染(无样式闪烁)
  通过建个div,把innerHTML放到这个element中,然后取出`<style>`和`<link>`元素,通过onload事件设置计数器,把这些元素放到head标签里,当这些元素加载完成后,通过类似promise的all的计数方法,再触发后续的把innerHTML放到页面上.

2. html中的script标签

在有些浏览器中,直接innerHTML一个script是不能生效的,必须创建,append才行

    var a = createElement("script")
    a.src = "xx";
    document.body.appendChild(a);

# 网易的本地模拟环境流程
后端三个环境:
1. 开发
2. 测试
3. 正式
本地通过本地server转发请求到开发环境
本地没问题push到测试环境进行测试
没问题后放到正式环境
部署流程:
后端svn通过Go系统做处理,合并,打包,替换ajax成本地文件后,
放到前端svn地址,告诉后端,然后后端再从前端svn拉取代码,部署到线上.

1. 通过nodejs创建本地模拟后台,gooda
2. gooda可以配置不同域名和对应的目录位置,访问对应域名时候访问对应目录
3. 请求的html,css,js文件直接从本地目录读,返回
4. 如果html涉及到后端语言,就把这个渲染了返回
5. 如果有ajax请求的话,后台会根据配置的路由进行选择,然后转发到真实的后台服务器
6. 后台都是一个IP入口,会根据请求的域名来转发到不同的系统


