# href="#" vs href="javascript:void(0)"(或者href="javascript:;")

# bowlder的问题之一：
3768行，removeChild之后，会导致有滑动的页面，滑动条位置由于删掉了dom而到了原位置的上部分，如果这时候有新的dom插入，位置就会有问题。（过多的页面bind真的好吗？那么多的回调函数句柄)

# debounce的再次学习
  debounce用于防止短时间内重复执行函数太多次，目的是指定一个时间wait，让函数的真正执行至少在wait秒之后，期间如果连续触发函数，那么函数的真正执行在最后一次触发的wait秒之后。
  当第一次触发的时候，设置timeout到wait秒以后执行later函数。然后再触发的时候，只要timeout非空（没开始执行），只记录触发的时间，不再处理。
  later函数会判断现在时间减去最近一次触发debounce的时间，如果小于指定的延迟，那么再次延迟wait-last的时间执行。
# throttle
 触发函数后，每隔wait秒执行一次，如果中间多次触发，不响应。

# 关于tabindex和键盘事件
https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets

# 关于js中的数字计算问题，一定要注意，js的计算是有小数点的，没有整数，注意处理

# 关于正则正向肯定查找?=
    用于匹配zcs?=asd仅当zcs后面跟着asd才匹配

# 关于new Function()的妙用
    通过传参数可以把参数写入到函数体中，这样有些表达式可以不通过eval而是写成函数体。
    function genFunc(expr) {
        return new Function('obj', 'with(obj)return ' + expr);
    }
首先可以通过表达式的结果动态的创建函数，而且可以传参数。

# 关于正则的逻辑|
    使用时候最好在需要或的地方加()，否则范围不定：
    /^abc|123$/ 对应实际是：

    /^ab(c|123)$/
    /^ab(c|12)3$/
    /^ab(c|1)23$/
    /^a(bc|1)23$/
    /^a(bc|12)3$/
    /^a(bc|123)$/
    /^(abc)|(1)23$/
    /^(abc)|(12)3$/
# content-type
 标识内容的mime-type
 请求头用来标识Post,put请求的formdata类型
 响应头用来标识返回内容的类型

# 关于http请求的请求体
[详见overstack回答](http://stackoverflow.com/questions/16339198/which-http-methods-require-a-body#answer-16339271)
    一般来说，除了trace请求，head,1xx,204,304返回外，其他的都可以有请求体。

    an entity-body is explicitly forbidden in TRACE requests only, all other request types are unrestricted (section 9, and 9.8 specifically)

    a message-body is explicitly forbidden in responses to HEAD requests (section 9, and 9.4 specifically)
    a message-body is explicitly forbidden in 1xx (informational), 204 (no content), and 304 (not modified) responses (section 4.3)

# 关于Number的toString方法  进制转换
    Number.toString()是数字转换成字符串的方法，接受一个参数，用来表示转换的进制。默认是10。
    如果(35).toString(36) = z;

#关于textContent
node接口的一个属性,用于获取或设置这个dom的文本.
注意用法:
node.textContent = "";
当设置textContent值的时候,这个节点的所有childNodes都被移除,替换成一个包含字符串的文本节点

# 关于bowlder中的defer
    每个defer自己的闭包的变量有:
        value: 当前defer运行的结果,通过def函数包装成含有then方法的对象.
        pending: 下一个defer包装好的待执行的回调函数列表.如果本defer结束运行,pending置为undefined.回调函数是:defer-next.resolve(realcallback(realvalue)) 来让链式调用往下走.


    resolve方法: 包裹真正的value到本defer的value,然后根据是否有pending,执行value.then(pending);value.then就是defer-next.resolve(callback(value)).然后defer-next又会查看是否有pending.决定是否调用下一个value.then
    

    then方法:新建一个defer并返回.
    包裹一个回调函数wrapcb: newdefer.resolve(callback(value)).保存传进来的真正的回调函数
    然后根据上一个promise的完成情况,决定是立刻执行:value.then(wrapcb)还是pending.push(wrapcb).

    def方法:当resolve触发的时候,包裹真正的value值变成一个promise:
          return {
            then: function(callback) {
              // // var result = defer();
              // // result.resolve(callback(value));
              // return result.promise;
              callback(value);
            }
          };
          其实这里这么写的主要用意是让ref("1233").then().then(),否则的话直接
          callback(value)也可以.触发:wrapback(value)=>defernext.resolve(realcb(realvalue))

          通过不停的创造defer,把下一个defer的回调放到本defer里,来实现链式的调用.
# bowlder中load如果带@的处理
  会把父亲组件的路径去掉文件,然后加上@后头路径

# 正则-exec和test使用全局标识匹配的问题
同一个使用全局标识的正则连续匹配会出现不正确匹配:因为lastIndex每次匹配都会变化,设置为匹配的最终位置下次匹配从lastIndex位置开始

    var reg = /test/g;
    console.log(reg.test("这是1个test"));
    console.log(reg.lastIndex);
    console.log(reg.test("test不错啊啊啊"));

# chrome debug快捷键

    触发断点效果: ctrl + F8
    下一个断点: F8
    跳到下一个调用栈: ctrl + ,
    返回上一个调用栈: ctrl + .
    在控制台中执行: Ctrl + Shift + E
    增加断点: ctrl + B

# 获得相对位置的方法:element.getBoundingClientRect
  
# canvas操作像素
    ImageData
    https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
