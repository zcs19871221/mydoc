# href="#" vs href="javascript:void(0)"(或者href="javascript:;")

# bowlder的问题之一：
3768行，removeChild之后，会导致有滑动的页面，滑动条位置由于删掉了dom而到了原位置的上部分，如果这时候有新的dom插入，位置就会有问题。（过多的页面bind真的好吗？那么多的回调函数句柄)

# debounce的再次学习
  debounce用于防止短时间内重复执行函数太多次，目的是指定一个时间wait，让函数的真正执行至少在wait秒之后，期间如果连续触发函数，那么函数的真正执行在最后一次触发的wait秒之后。
  当第一次触发的时候，设置timeout到wait秒以后执行later函数。然后再触发的时候，只要timeout非空（没开始执行），只记录触发的时间，不再处理。
  later函数会判断现在时间减去最近一次触发debounce的时间，如果小于指定的延迟，那么再次延迟wait-last的时间执行。
# throttle
 触发函数后，每隔wait秒执行一次，如果中间多次触发，不响应。

# 关于tabindex和键盘事件
https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets

# 关于js中的数字计算问题，一定要注意，js的计算是有小数点的，没有整数，注意处理

# 关于正则正向肯定查找?=
    用于匹配zcs?=asd仅当zcs后面跟着asd才匹配

# 关于new Function()的妙用
    通过传参数可以把参数写入到函数体中，这样有些表达式可以不通过eval而是写成函数体。
    function genFunc(expr) {
        return new Function('obj', 'with(obj)return ' + expr);
    }
首先可以通过表达式的结果动态的创建函数，而且可以传参数。

# 关于正则的逻辑|
    使用时候最好在需要或的地方加()，否则范围不定：
    /^abc|123$/ 对应实际是：

    /^ab(c|123)$/
    /^ab(c|12)3$/
    /^ab(c|1)23$/
    /^a(bc|1)23$/
    /^a(bc|12)3$/
    /^a(bc|123)$/
    /^(abc)|(1)23$/
    /^(abc)|(12)3$/
# content-type
 标识内容的mime-type
 请求头用来标识Post,put请求的formdata类型
 响应头用来标识返回内容的类型

# 关于http请求的请求体
[详见overstack回答](http://stackoverflow.com/questions/16339198/which-http-methods-require-a-body#answer-16339271)
    一般来说，除了trace请求，head,1xx,204,304返回外，其他的都可以有请求体。

    an entity-body is explicitly forbidden in TRACE requests only, all other request types are unrestricted (section 9, and 9.8 specifically)

    a message-body is explicitly forbidden in responses to HEAD requests (section 9, and 9.4 specifically)
    a message-body is explicitly forbidden in 1xx (informational), 204 (no content), and 304 (not modified) responses (section 4.3)

# 关于Number的toString方法  进制转换
    Number.toString()是数字转换成字符串的方法，接受一个参数，用来表示转换的进制。默认是10。
    如果(35).toString(36) = z;

#关于textContent
node接口的一个属性,用于获取或设置这个dom的文本.
注意用法:
node.textContent = "";
当设置textContent值的时候,这个节点的所有childNodes都被移除,替换成一个包含字符串的文本节点

# 关于bowlder中的defer
    每个defer自己的闭包的变量有:
        value: 当前defer运行的结果,通过def函数包装成含有then方法的对象.
        pending: 下一个defer包装好的待执行的回调函数列表.如果本defer结束运行,pending置为undefined.回调函数是:defer-next.resolve(realcallback(realvalue)) 来让链式调用往下走.


    resolve方法: 包裹真正的value到本defer的value,然后根据是否有pending,执行value.then(pending);value.then就是defer-next.resolve(callback(value)).然后defer-next又会查看是否有pending.决定是否调用下一个value.then
    

    then方法:新建一个defer并返回.
    包裹一个回调函数wrapcb: newdefer.resolve(callback(value)).保存传进来的真正的回调函数
    然后根据上一个promise的完成情况,决定是立刻执行:value.then(wrapcb)还是pending.push(wrapcb).

    def方法:当resolve触发的时候,包裹真正的value值变成一个promise:
          return {
            then: function(callback) {
              // // var result = defer();
              // // result.resolve(callback(value));
              // return result.promise;
              callback(value);
            }
          };
          其实这里这么写的主要用意是让ref("1233").then().then(),否则的话直接
          callback(value)也可以.触发:wrapback(value)=>defernext.resolve(realcb(realvalue))

          通过不停的创造defer,把下一个defer的回调放到本defer里,来实现链式的调用.
# bowlder中load如果带@的处理
  会把父亲组件的路径去掉文件,然后加上@后头路径

# 正则-exec和test使用全局标识匹配的问题
同一个使用全局标识的正则连续匹配会出现不正确匹配:因为lastIndex每次匹配都会变化,设置为匹配的最终位置下次匹配从lastIndex位置开始

    var reg = /test/g;
    console.log(reg.test("这是1个test"));
    console.log(reg.lastIndex);
    console.log(reg.test("test不错啊啊啊"));

# chrome debug快捷键

    触发断点效果: ctrl + F8
    下一个断点: F8
    跳到下一个调用栈: ctrl + ,
    返回上一个调用栈: ctrl + .
    在控制台中执行: Ctrl + Shift + E
    增加断点: ctrl + B

# 获得相对位置的方法:element.getBoundingClientRect
  
# canvas操作像素
    ImageData
    https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas

#元素相对位置
## 视窗位置:浏览器可见位置,不包含滚动条.
## element.getBoundingClientRect 
    获取相对于视窗(就是浏览器左上角的位置),这个位置是动态计算的,包含这个元素内层的滚动,但是
    不包含整个浏览器的滚动条的位置,如果要计算相对于页面内容左上角的位置,需要加上
    window.pageYOffset和window.pageXOffset 
    https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect
![](getBoundingClientRect.jpg)

## offsetLeft, offsetParent 
相对于offsetParent的偏移位置
offsetParent是一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table 元素对象或根元素（标准模式下为 html；quirks 模式下为 body）。
所以对于中间的元素来说,如果有滚动条的话,随着滚动,元素的位置会上下,左右移动,因此还应该把所有父元素(除去body或window)的滚动条移动距离加上或减去.

    function getPos(e) {
        var left = 0,
            top = 0,
            scrollLeft = 0,
            scrollTop = 0,
            b = e.parentNode;
        while (e) {
          left = left + e.offsetLeft;
          top = top + e.offsetTop;
          e = e.offsetParent;
        }
        while (b && (b.nodeName.toLowerCase() !== "body")) {
          scrollLeft = scrollLeft + (b.scrollLeft||0);
          scrollTop = scrollTop + (b.scrollTop || 0);
          b = b.parentNode;
        }
        return {
          left: left - scrollLeft,
          top: top - scrollTop
        }
    }
## 关于图片加载完成的回调函数
 先看正确的例子:
 var img = new Image();
 img.onload = function() {
    img.onload = null;
    callback();
 }
 img.src = url;

几个点:
  1.回调函数中不要引用img,会造成低版本的IE无法回收内存(自己引用自己),所以执行的时候如果设置回调函数为null,一方面保证内存不会泄漏,第二方面防止GIF图重复触发onload事件
  2.为什么src要放到onload后头,因为如果有缓存的图片,刚设置src可能瞬间就要触发onload,这时候有的浏览器onload事件还没有设置,所以先设置onload
  3.不要使用complete属性
  4.无论是否有缓存,加载完成都会触发onload事件

  # v8的设计架构
  https://github.com/v8/v8/wiki/Design%20Elements
  http://blog.pluskid.org/?p=186

js为什么慢?因为它是动态语言,每次访问一个对象的时候,都得动态的查找它的位置,
而想java或c,每一个对象的偏移位置都是确定的,根据编译时候它们固定的类结构,,因此一次查找就是一个取偏移值的过程,很快.
1.v8的目标就是内部实现隐藏的类,新建对象创建一个隐藏类,每个属性创建一个,指定属性的偏移值.
2.v8的垃圾回收快:
  1.垃圾回收时候会暂停程序
  2.只暂停部分的内存空间
  3.每个对象都有指针

# 不能冒泡的js事件
    submit, focus, blur, load, unload, change, reset, scroll, most of the DOM events (DOMFocusIn, DOMFocusOut, DOMNodeRemoved, etc), mouseenter, mouseleave, etc

# 关于动态加载html的若干注意
1. html中的`<style>`和`<link>`处理   
  先放到head中,等加载完成后,再把html append到页面上防止页面二次渲染(无样式闪烁)
  通过建个div,把innerHTML放到这个element中,然后取出`<style>`和`<link>`元素,通过onload事件设置计数器,把这些元素放到head标签里,当这些元素加载完成后,通过类似promise的all的计数方法,再触发后续的把innerHTML放到页面上.

2. html中的script标签

在有些浏览器中,直接innerHTML一个script是不能生效的,必须创建,append才行

    var a = createElement("script")
    a.src = "xx";
    document.body.appendChild(a);

# 网易的本地模拟环境流程
后端三个环境:
1. 开发
2. 测试
3. 正式
本地通过本地server转发请求到开发环境
本地没问题push到测试环境进行测试
没问题后放到正式环境
部署流程:
后端svn通过Go系统做处理,合并,打包,替换ajax成本地文件后,
放到前端svn地址,告诉后端,然后后端再从前端svn拉取代码,部署到线上.

1. 通过nodejs创建本地模拟后台,gooda
2. gooda可以配置不同域名和对应的目录位置,访问对应域名时候访问对应目录
3. 请求的html,css,js文件直接从本地目录读,返回
4. 如果html涉及到后端语言,就把这个渲染了返回
5. 如果有ajax请求的话,后台会根据配置的路由进行选择,然后转发到真实的后台服务器
6. 后台都是一个IP入口,会根据请求的域名来转发到不同的系统

# git学习
1. 和其他代码管理的区别
    1. cvs的问题:单点故障,影响所有客户端.服务器挂了,数据全丢了
    2. git是分布式的,每个节点保存所有的代码,服务器挂了,本地提交,服务器数据没了,本地代码可恢复服务器的.
2. git特点
    1. 保存的是每个版本文件的快照,而不是其他的差异列表
    2. 安全性高,每次修改,上传都做md5计算

# 制作表头固定,表头需要滚轮滑动,左侧第一列固定的表格
  html结构是:
    <div width="某个值">
      <header style="overflow-x: hidden">
      </header>
      <div style="overflow-y: auto;overflow-x:hidden">
        <firstColun style="position:absolute;left:scrollLeft">
      </div>
    </div>
  这样做出来,表头和内容实际是两个独立的滚动部分.然后让表头的横向滚动hidden,
  让内容垂直滚动,横向滚动hidden.然后通过内容的滚动,触发scroll事件,让表头的scrollLeft和内容的scrollLeft同值,实现内容滚动,表头也滚动.然后再设置第一列的元素为绝对定位,横向滚动时候,让这些元素的left属性等于scrollLeft.

# git技巧
## gitignore
 文件 .gitignore 的格式规范如下：
 [详见Gitbook回答](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件)

  1. 所有空行或者以 ＃ 开头的行都会被 Git 忽略。
  2. 可以使用标准的 glob 模式匹配。
  3. 匹配模式可以以（/）开头防止递归。
  4. 匹配模式可以以（/）结尾指定目录。
  5. 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。

## 防止输入用户和密码
1. 给~/.gitconfig增加如下: 

    [credential]
        helper = store --file ~/.pwd
2. 编辑.pwd文件增加
      username=[]
      password=[]

# 等比例盒子
    https://w3ctech.com/topic/1483

# 图片截取
1. 设置好父亲div的比例,按照比例,让image窄一点的边max-height100%,然后
截取长的边(多出来的部分-长度)/2对应的margin,父亲divoverflow hidden
2. 设置背景图片,background-size: cover background-position: center

# bowlder的数据绑定
## 数据结构
 scope widget view model
model是双向绑定
  通过向model的items里添加项目,形成数据<->视图的绑定.
  添加items时候,会绑定dom改变的事件函数,比如input对应change等.
  改变dom会触发事件,改变scope里的值
  改变值的时候,实际上是触发scope.refresh的时候,会遍历item里记录的数据,改变页面的dom
view是单向绑定,只会当refresh时候,遍历views里的item,改变对应的dom

#sublimte text技巧
1. 文件内搜索排除文件夹 
    
        -*/name_of_dir/*

# nodejs http.request的keepalvie的真像
目标是复用tcp链接,只有当设置了请求options的agent参数才可以

    new http.Agent({
      keepAlive: true,
      maxSockets: 1
    });
在node中,这个agent只有当sockets占满的情况下,才会对tcp池进行复用.
如果访问量小的话,maxSockets设置小一些,减少tcp创建,握手的时间,充分复用.
如果访问量大,maxSockets设置大一些,这样就不会因为访问量过大,导致少量的tcp链接被占用,然后等待tcp释放后再使用.