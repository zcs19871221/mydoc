#html
[a标签设置点击事件如何设置href属性](#user-content-a标签设置点击事件如何设置href属性);

[关于tabindex和键盘事件](#user-content-关于tabindex和键盘事件);

#js
[debounce的再次学习](#user-content-debounce的再次学习);

[关于正则正向肯定查找](#user-content-关于正则正向肯定查找);

[function构造函数的妙用](#user-content-function构造函数的妙用);

[关于正则的逻辑或](#user-content-关于正则的逻辑或);

[throttle](#user-content-throttle);

[关于js中的数字计算问题](#user-content-关于js中的数字计算问题);

[关于Number的toString方法](#user-content-关于Number的toString方法);

[关于textContent](#user-content-关于textContent);

[关于bowlder中的defer](#user-content-关于bowlder中的defer);

[bowlder中load如果带@的处理](#user-content-bowlder中load如果带@的处理);

[正则exec和test使用全局标识匹配的问题](#user-content-正则exec和test使用全局标识匹配的问题);

# http协议相关
[content-type](#user-content-content-type);

[关于http请求的请求体](#user-content-关于http请求的请求体);




# a标签设置点击事件如何设置href属性
## 解释
  如果从想使用点击这个事件绑定到a标签这个事情来说的话,使用href="javascript:void(0),两个原因:

  1. 如果使用#的话,必须在函数结尾加上return false或者preventDefault语法,
     防止默认的跳到页面开始位置.
  2. 如果执行函数中抛出了错误,那么如果没有很好地错误处理的话,错误后面的
     代码就不会执行,那么就会跳到页面开始的位置.

  但是,更好的体验是:
  a标签的作用就是打开一个新的连接,所以如果你确实是想打开一个新的连接的话,
  直接使用href属性指向你的目标连接,而不要用onclick,
  因为onclick在使用滚轮点击和浏览器禁用javascript的情况下会无效.
  所以尽量不要在a标签中使用onclick,因为它还会导致侵入式的编程,并且不利于
  拓展和维护,因为在html中耦合了太多的代码.如果要要是用的话,直接写个button样式
  或者不给a标签增加href属性.

## 参考
[stackoverflow](http://stackoverflow.com/questions/134845/which-href-value-to-use-for-javascript-links-or-javascriptvoid0)

[非侵入式javascript](https://en.wikipedia.org/wiki/Unobtrusive_JavaScript)

[渐进增强](https://en.wikipedia.org/wiki/Progressive_enhancement)


# debounce的再次学习
  debounce用于防止短时间内重复执行函数太多次，目的是指定一个时间wait，
  让函数的真正执行至少在wait秒之后，期间如果连续触发函数，
  那么函数的真正执行在最后一次触发的wait秒之后。
  当第一次触发的时候，设置timeout到wait秒以后执行later函数。然后再触发的时候，只要timeout非空（没开始执行），只记录触发的时间，参数等,不再处理。
  later函数会判断现在时间减去最近一次触发debounce的时间，如果小于指定的延迟，那么再次延迟wait-last的时间执行。

# throttle
 触发函数后，每隔wait秒执行一次，如果中间多次触发，不响应。

# 关于tabindex和键盘事件
https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets

# 关于js中的数字计算问题
一定要注意，js的计算是有小数点的，没有整数，注意处理

# 关于正则正向肯定查找
    用于匹配zcs?=asd仅当zcs后面跟着asd才匹配

# function构造函数的妙用
    通过传参数可以把参数写入到函数体中，这样有些表达式可以不通过eval而是写成函数体。
    function genFunc(expr) {
        return new Function('obj', 'with(obj)return ' + expr);
    }
首先可以通过表达式的结果动态的创建函数，而且可以传参数。
## 构造函数和直接定义在作用域上的不同
  通过Function构造函数创建的函数,其作用域只有自己和全局两个,而不是像一般
  函数,作用域还包含了其定义的作用域.
## 参考
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

# 关于正则的逻辑或
    使用时候最好在需要或的地方加()，否则范围不定：
    /^abc|123$/ 对应实际是：

    /^ab(c|123)$/
    /^ab(c|12)3$/
    /^ab(c|1)23$/
    /^a(bc|1)23$/
    /^a(bc|12)3$/
    /^a(bc|123)$/
    /^(abc)|(1)23$/
    /^(abc)|(12)3$/
# content-type
 标识内容的mime-type
 请求头用来标识Post,put请求的formdata类型
 响应头用来标识返回内容的类型

# 关于http请求的请求体
[详见overstack回答](http://stackoverflow.com/questions/16339198/which-http-methods-require-a-body#answer-16339271)
    一般来说，除了trace请求，
    head,1xx,204,304返回外，其他的都可以有请求体。

    an entity-body is explicitly forbidden in TRACE requests only, 
    all other request types are unrestricted 
    (section 9, and 9.8 specifically)

    a message-body is explicitly forbidden in responses to HEAD 
    requests (section 9, and 9.4 specifically)
    a message-body is explicitly forbidden in 1xx (informational), 
    204 (no content), and 304 (not modified) responses (section 4.3)

# 关于Number的toString方法
    Number.toString()是数字转换成字符串的方法，接受一个参数，用来表示转换的进制。默认是10。
    如果(35).toString(36) = z;

#关于textContent
node接口的一个属性,用于获取或设置这个dom的文本.
注意用法:
node.textContent = "";
当设置textContent值的时候,这个节点的所有childNodes都被移除,替换成一个包含字符串的文本节点,在jquery中用作

# 关于bowlder中的defer
[参见我的源代码阅读](%e6%ba%90%e4%bb%a3%e7%a0%81%e8%a7%a3%e8%af%bb%2fpromise%e8%a7%a3%e8%af%bb%e5%92%8c%e8%87%aa%e5%b7%b1%e7%9a%84%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0.txt)

# bowlder中load如果带@的处理
  会把父亲组件的路径去掉文件,然后加上@后头路径

# 正则exec和test使用全局标识匹配的问题
同一个使用全局标识的正则连续匹配会出现不正确匹配:因为lastIndex每次匹配都会变化,设置为匹配的最终位置下次匹配从lastIndex位置开始

    var reg = /test/g;
    console.log(reg.test("这是1个test"));
    console.log(reg.lastIndex);
    console.log(reg.test("test不错啊啊啊"));

# chrome debug快捷键

    触发断点效果: ctrl + F8
    下一个断点: F8
    跳到下一个调用栈: ctrl + ,
    返回上一个调用栈: ctrl + .
    在控制台中执行: Ctrl + Shift + E
    增加断点: ctrl + B
    debug多行: shift + enter

# 获得相对位置的方法:element.getBoundingClientRect
  
# canvas操作像素
    ImageData
    https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas

#元素相对位置
## 视窗位置:浏览器可见位置,不包含滚动条.
## element.getBoundingClientRect 
    获取相对于视窗(就是浏览器左上角的位置),这个位置是动态计算的,包含这个元素内层的滚动,但是
    不包含整个浏览器的滚动条的位置,如果要计算相对于页面内容左上角的位置,需要加上
    window.pageYOffset和window.pageXOffset 
    https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect
![](getBoundingClientRect.jpg)

## offsetLeft, offsetParent 
相对于offsetParent的偏移位置
offsetParent是一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table 元素对象或根元素（标准模式下为 html；quirks 模式下为 body）。
所以对于中间的元素来说,如果有滚动条的话,随着滚动,元素的位置会上下,左右移动,因此还应该把所有父元素(除去body或window)的滚动条移动距离加上或减去.

    function getPos(e) {
        var left = 0,
            top = 0,
            scrollLeft = 0,
            scrollTop = 0,
            b = e.parentNode;
        while (e) {
          left = left + e.offsetLeft;
          top = top + e.offsetTop;
          e = e.offsetParent;
        }
        while (b && (b.nodeName.toLowerCase() !== "body")) {
          scrollLeft = scrollLeft + (b.scrollLeft||0);
          scrollTop = scrollTop + (b.scrollTop || 0);
          b = b.parentNode;
        }
        return {
          left: left - scrollLeft,
          top: top - scrollTop
        }
    }
## 关于图片加载完成的回调函数
 先看正确的例子:
 var img = new Image();
 img.onload = function() {
    img.onload = null;
    callback();
 }
 img.src = url;

几个点:
  1.回调函数中不要引用img,会造成低版本的IE无法回收内存(自己引用自己),所以执行的时候如果设置回调函数为null,一方面保证内存不会泄漏,第二方面防止GIF图重复触发onload事件
  2.为什么src要放到onload后头,因为如果有缓存的图片,刚设置src可能瞬间就要触发onload,这时候有的浏览器onload事件还没有设置,所以先设置onload
  3.不要使用complete属性
  4.无论是否有缓存,加载完成都会触发onload事件

  # v8的设计架构
  https://github.com/v8/v8/wiki/Design%20Elements
  http://blog.pluskid.org/?p=186

js为什么慢?因为它是动态语言,每次访问一个对象的时候,都得动态的查找它的位置,
而想java或c,每一个对象的偏移位置都是确定的,根据编译时候它们固定的类结构,,因此一次查找就是一个取偏移值的过程,很快.
1.v8的目标就是内部实现隐藏的类,新建对象创建一个隐藏类,每个属性创建一个,指定属性的偏移值.
2.v8的垃圾回收快:
  1.垃圾回收时候会暂停程序
  2.只暂停部分的内存空间
  3.每个对象都有指针

# 不能冒泡的js事件
    submit, focus, blur, load, unload, change, reset, scroll, most of the DOM events (DOMFocusIn, DOMFocusOut, DOMNodeRemoved, etc), mouseenter, mouseleave, etc

# 关于动态加载html的若干注意
1. html中的`<style>`和`<link>`处理   
  先放到head中,等加载完成后,再把html append到页面上防止页面二次渲染(无样式闪烁)
  通过建个div,把innerHTML放到这个element中,然后取出`<style>`和`<link>`元素,通过onload事件设置计数器,把这些元素放到head标签里,当这些元素加载完成后,通过类似promise的all的计数方法,再触发后续的把innerHTML放到页面上.

2. html中的script标签

在有些浏览器中,直接innerHTML一个script是不能生效的,必须创建,append才行

    var a = createElement("script")
    a.src = "xx";
    document.body.appendChild(a);

# 网易的本地模拟环境流程
后端三个环境:
1. 开发
2. 测试
3. 正式
本地通过本地server转发请求到开发环境
本地没问题push到测试环境进行测试
没问题后放到正式环境
部署流程:
后端svn通过Go系统做处理,合并,打包,替换ajax成本地文件后,
放到前端svn地址,告诉后端,然后后端再从前端svn拉取代码,部署到线上.

1. 通过nodejs创建本地模拟后台,gooda
2. gooda可以配置不同域名和对应的目录位置,访问对应域名时候访问对应目录
3. 请求的html,css,js文件直接从本地目录读,返回
4. 如果html涉及到后端语言,就把这个渲染了返回
5. 如果有ajax请求的话,后台会根据配置的路由进行选择,然后转发到真实的后台服务器
6. 后台都是一个IP入口,会根据请求的域名来转发到不同的系统

# git学习
1. 和其他代码管理的区别
    1. cvs的问题:单点故障,影响所有客户端.服务器挂了,数据全丢了
    2. git是分布式的,每个节点保存所有的代码,服务器挂了,本地提交,服务器数据没了,本地代码可恢复服务器的.
2. git特点
    1. 保存的是每个版本文件的快照,而不是其他的差异列表
    2. 安全性高,每次修改,上传都做md5计算
3. git配置
  中文文件名显示：

      #不对0x80以上的字符进行quote，解决git status/commit时中文文件名乱码
      git config --global core.quotepath false

# 制作表头固定,表头需要滚轮滑动,左侧第一列固定的表格
  html结构是:
    <div width="某个值">
      <header style="overflow-x: hidden">
      </header>
      <div style="overflow-y: auto;overflow-x:hidden">
        <firstColun style="position:absolute;left:scrollLeft">
      </div>
    </div>
  这样做出来,表头和内容实际是两个独立的滚动部分.然后让表头的横向滚动hidden,
  让内容垂直滚动,横向滚动hidden.然后通过内容的滚动,触发scroll事件,让表头的scrollLeft和内容的scrollLeft同值,实现内容滚动,表头也滚动.然后再设置第一列的元素为绝对定位,横向滚动时候,让这些元素的left属性等于scrollLeft.

# git技巧
## gitignore
 文件 .gitignore 的格式规范如下：
 [详见Gitbook回答](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件)

  1. 所有空行或者以 ＃ 开头的行都会被 Git 忽略。
  2. 可以使用标准的 glob 模式匹配。
  3. 匹配模式可以以（/）开头防止递归。
  4. 匹配模式可以以（/）结尾指定目录。
  5. 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。

## 防止输入用户和密码
1. 给~/.gitconfig增加如下: 

    [credential]
        helper = store --file ~/.pwd
2. 编辑.pwd文件增加
      username=[]
      password=[]

# 等比例盒子
    https://w3ctech.com/topic/1483

# 图片截取
1. 设置好父亲div的比例,按照比例,让image窄一点的边max-height100%,然后
截取长的边(多出来的部分-长度)/2对应的margin,父亲divoverflow hidden
2. 设置背景图片,background-size: cover background-position: center

# bowlder的数据绑定
## 数据结构
 scope widget view model
model是双向绑定
  通过向model的items里添加项目,形成数据<->视图的绑定.
  添加items时候,会绑定dom改变的事件函数,比如input对应change等.
  改变dom会触发事件,改变scope里的值
  改变值的时候,实际上是触发scope.refresh的时候,会遍历item里记录的数据,改变页面的dom
view是单向绑定,只会当refresh时候,遍历views里的item,改变对应的dom

#sublimte text技巧
1. 文件内搜索排除文件夹 
    
        -*/name_of_dir/*

# nodejs http.request的keepalvie的真像
目标是复用tcp链接,只有当设置了请求options的agent参数才可以

    new http.Agent({
      keepAlive: true,
      maxSockets: 1
    });
在node中,这个agent只有当sockets占满的情况下,才会对tcp池进行复用.
如果访问量小的话,maxSockets设置小一些,减少tcp创建,握手的时间,充分复用.
如果访问量大,maxSockets设置大一些,这样就不会因为访问量过大,导致少量的tcp链接被占用,然后等待tcp释放后再使用.

#http包头的格式
    HTTP1.1规定的HTTP包头格式如下
    请求方法 URI 协议/版本
    请求头：0或多行
    \r\n
    正文部分
    --------------------
    协议/版本 状态码 状态描述
    响应头：0或多行
    \r\n
    正文部分

# css换行
1. white-space 
处理空白
2. word-wrap
处理断句,如果一行放不下,首先会尝试放下一行看能不能放完整的,如果可以的话,
就放到下一行.
3. word-break
不考虑断句,直接有空白就断掉.
4. 超出字符串进行截取

      text-overflow: ellipsis;
      white-space: no-wrap;                
      overflow: hidden;

# js事件-mouseover(mouseout)和mouseenter(mouseleave)
mouseover冒泡,在绑定元素内部的所有子元素的移动都会触发mouseover事件.
mouseenter不冒泡,绑定元素内部的移动不会触发该事件,只有进出绑定元素的时候
才会触发事件.

# offsetWidth, clientWidth, scrollWidth
scrollWidth：
对象的实际内容的宽度，不包边线宽度，会随对象中内容超过可视区后而变大。 
clientWidth：
对象内容的可视区的宽度，不包滚动条等边线，会随对象显示大小的变化而改变。 
offsetWidth：
对象整体的实际宽度，包滚动条等边线，会随对象显示大小的变化而改变。
![image](./client-offset.png)
同样可以用来判断是否有溢出或隐藏内容:
`scrollWidth > clientWidth`

# 边框三角
原理就是这张图
![image](./边框形状.png)

如果要实现不是实心的三角,使用另一个三角覆盖这个三角的一部分.

[参考](http://www.zhangxinxu.com/wordpress/2010/03/%E7%BA%AFcss%E5%AE%9E%E7%8E%B0%E5%90%84%E7%B1%BB%E6%B0%94%E7%90%83%E6%B3%A1%E6%B3%A1%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%95%88%E6%9E%9C/)