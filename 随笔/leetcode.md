
# 字符串前头的空字符
`while(s[i] === '') i++;`
# 根据正或负符号取得1或者-1
`sign = 1 - 2 * [s[i] == '-'];`
# 字符串转数字'12345'

    while (str[i] >= '0' && str[i] <= '9') {
        base = base * 10 + (str[i++] - '0');
    }
# 数组中找缺少值

        两个相同数字异或为0。
        任何数字和0异或为那个数字本身。
        result = result ^ i ^ nums[i]。那么相同的异或为0,0异或其他的为自己本身
        这样a^b^a = b;
# 找出数组中重复值，不使用额外空间

# Best Time to Buy and Sell Stock
我的做法是，遍历一遍，找出股票中所有的高峰点和波谷点

    while (num[i - 1] > num[i]) {
        i++;
    }
    low = num[i]
    while (num[i - 1] < num[i]) {
        i++;
    }
    hight = num[i];
    然后这时候遍历low，计算high - low的值，保存数组
    最后计算这个数组的最大值。

好的做法是，遍历的时候，维护两个变量，一个当前最大值，一个全部最大值：

    curMax，soFarMax
    curMax = Math.max(0, curMax += num[i] - num[i - 1]);
    soFarMax = Math.max(soFarMax, curMax);

它的思路类似于我的，在curMax = Math.max(0, curMax += num[i] - num[i - 1]);的过程中就是后面值减前面值，如果是上坡，那么就是高峰减低谷，如果是下坡，它还计算了第n个峰值和之前低谷的差：比如序列
[1, 3, 2, 5] 谷底1，峰值3，谷底2，峰值5.
第一个差值是2，然后第二个差值是-1，加上之前的2， -1 + 2 = 1，第三个差值是5-2 + 1 = 4。也就是说如果谷底比前一个谷底高的话，下一个峰值减当前谷底的值加上上一个峰值减谷底的值，得到正确的值。如果谷底比前一个谷底低，那么下一个峰值减前一个谷底的值一定比下一个峰值减这个谷底的值小，就没有记录必要。

# Unique Paths II
一个m*n的数组，从左上到右下有多少种路径。
II新增的条件是m*n中随机有障碍点，障碍点不能通过。

之前的动态规划思路是dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
这个思路可以延续，但是得增加对当前点是否障碍和边界线上是否有障碍的判断。

新的思路是，dp只要一个数组，因为按照上一个思路计算的方式也是按行的，比如一个
障碍是
0 1 0
0 0 0
0 0 0的题目，
计算方式是
1. 1 0 0
2. 1 1 1
3. 1 2 3
也就是说是按照行计算的，那么一开始把数组设置成
dp = [1, 0, ....0];
if (obstacle[i][j] === 1) {
    dp[j] = 0;
}
if (j > 0) {
    dp[j] = dp[j] + dp[j - 1];
}
非常巧妙，三个边界条件都覆盖到了：
1. 如果是第一行第一列，那么默认dp[0] = 1，第一行剩下的套用dp[j] = dp[j] + dp[j - 1]; 因为dp[i]默认是0，所以就看上一个是否为0（是否障碍），如果是，那么这一行都是0
2. 第一列条件，默认dp[0] = 1;如果第一列不再遇到障碍点，那么dp[0]不会设置值。只要对应点是障碍点，那么设置dp[0] = 0,以后就都是0.

# 归并a,b两个有序数组在a上
一看就知道是二指针法，优秀的方法是把比较开始的指针放到尾部，表示新数组的下标k初始化设置成m+n，这样从尾部开始比较，然后依次放入。就只有一次循环。我一开始的方法是从0开始比较，需要形如：

    while (i < m && i < j) {
        while (n1[i] < n2[j]) {
            i++
        }
        while (n1[i] > n2[j]) {
            j++
        }
    }
我的做法就是在i处找相对于j处比j小的最大点，然后再在j处找相对于i处比i小的最大点，然后再循环，直到i或j到头。
而最佳方法是从尾部找，尾部永远都是最大点，不用比较，而且从尾部给n1赋值不破坏n1的结构。

# 回溯法关键点
1. 设置起始点start，因为不需要遍历之前遍历过的

      123
      12 13 
      2开始是23而不是21，否则会有重复
      
2. 设置tmp数组暂存状态，调用递归后pop，返回上一个状态，使用一个array而不必每次
遍历赋值新的数组

    tmp.push(e);
    digui(start, ar, tmp);
    tmp.pop();

3. 不使用额外空间类似2的实现
    nums[a] = nums[a] ^ 256;
    digui();
    nums[a] = nums[a] ^ 256;

# 矩阵转换数组，当有矩阵的情况下考虑转换成数组处理或反之
n * m matrix convert to an array => matrix[x][y] => a[x * m + y]

an array convert to n * m matrix => a[x] =>matrix[x / m][x % m];
