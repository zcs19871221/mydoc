# 核心思想

    UI 就是数据，展示是数据，用户交互是数据转换。

    在开发前，花费多一些时间考虑如何从界面抽象出数据模型。

# 开发步骤

1.  画出草图(如果无交互)
2.  分离并写用例：
    1. 能做的操作 - 比如点击编辑：出现编辑框并且隐藏添加框
    2. 区分操作是组件内的局部操作(状态保存在组建内部)，还是作为一个 action(状态保存在 store 中)
    3. 能看到的界面 - 比如这个列表能看到名称，颜色，数量，并且当有未完成工作时，数量显示红色。
    4. 列个单子把这些用例写下来。
3.  app 状态建模成数据，写出 reducer 默认状态，原则如下：
    1. 只储存最小化的核心状态，不储存衍生状态
    2. 状态数据必须覆盖 2 中的所有用例，即：能看到的界面和能做的操作。
4.  编写控制台版本 app。

    1. 除了展示型组件，其他地方都使用持久化数据 immutable.js。
    2. 编写 actions - 依据 2 中的 action 操作用例逐条写 - 满足用户能操作什么。
    3. 编写 reducer。
    4. 编写 selector - 依据 2 中展示用例逐条编写 -用来生成衍生状态和视图业务数据 - 满足用户能看到什么。
    5. 编写 connect，把视图数据和触发操作的函数版定到组件上，原则：
       1. 把 selector 引用进来用来生成展示数据，如果是展示型组件要把 immutable 转换成 js 对象。
       2. 把 action 引用进来用来触发操作。
       3. 把 1 的数据和 2 的函数和组件结合。注意，组件要减少无效的 props 传递，比如父组件 A 不关心 props X，只有他的子组件 B 关心，那么直接把属性 X connect 到 B。
    6. 写 actions,reducer,selector 和 connect 的单元测试。(为了更好的分离依赖，在编写代码时候，不要直接使用同一个文件下的函数、变量的引用，这样耦合在一起，也没法在测试的时候分离，解决方法有两个：1. 编写类，通过 this 或者类名（静态）引用 2. 文件拆分，没有依赖的文件单独写，有依赖的拆分出去，把依赖的部分通过引入模块的方式进行解耦. 这样可以通过 jest.mock 模拟)

5.  写图形界面（写渲染组件）
    1. 一开始只写 html
    2. 展示：组件只是 state 到 dom 的映射 交互：通过绑定 dom 事件到 actions 实现。
    3. 所有的业务逻辑放到 actions 和 selector 中实现。
    4. 组件脱离逻辑，优点是更易复用，而且逻辑都在 actions 或 selector，更易测试。
