# 目标使用
gulp + webpack
实现自动化：
1. 开发时：
监视文件，自动重启之类的
2. 整合
  1. 检查js-eslint,css,html语法
  2. 语法编译es6-babel,less
  3. 合并，压缩，混淆js，css,图片，并生成souceMap文件
  4. 版本控制
  5. 整合webpack
eslint，babel编译es6，
[参考](https://github.com/vincentSea/gulp-demo)

# gulp语法
1. src(globs[, options])
options: {
    base: 默认是globs路径中从头开始静态的路径,可以显示设置
    buffer: 默认是true，如果设置成true，将会用流方式，有利于大文件读取节省内存
}
2. dest(path[, options])
path根据base路径来计算

3. task

4. watch

# gulp-eslint语法
## eslint()进行检查 
## eslint.format(formatter, output)输出结果，output可以是函数或者可写流。

# 监控文件重启
## webpackServer的坑
webpackServer是一个很有用的东西，可以实现一个开发环境服务器。
实现监控文件改变后自动刷新页面和代理等功能。但是没想到配一个自动刷新服务器竟然有那么多坑，花了好几天。

自动刷新可以通过在webpack.config.js中的devServer中配置，它的实现过程是：
1. 监视contentBase文件，看是否有改变
2. 如果有改变，根据webpack.config.js中的配置重新打包，打包后不刷新文件。请求的时候通过websocket传递给浏览器。

几个关键点：
1. contentBase属性：告诉server监视哪些文件夹，以及浏览器请求的起始位置。但是这个目录下请求的文件实际上都走的是静态文件，就是文件夹里的文件。默认是./
2. publicPath属性：告诉server哪些是编译后的文件，这样server在返回浏览器的时候才能决定是使用内存里的打包好的文件还是使用系统里的文件。比如我打包一个bundle.js文件，有若干个html引用它。如果我没设置publicPath属性的话，请求的都是原始文件系统的文件，而不是你修改后，server打包到内存里的文件。如果我设置了，就告诉了server这个bundle.js文件请求的都是内存中最新的。
3. publicPath属性值必须以/开头，否则就无效！！
4. publicPath的地址是相对于contentBase属性

所以结论是必须设置publicPath属性，而且只能设置具体的一个目录。
如果我平常开发的话，涉及多个目录下文件的修改怎么弄。

# gulp+browsersync
比较好用，就是不智能，所有监控的文件只要已修改，就会自动刷新页面。不管页面和修改文件是否相关。

# webpack可以通过--env.xxx传递参数

# sourceMap的问题

# eslint，react，webpack整合
# 安装文件
npm install babel-eslint eslint eslint-plugin-react --save-dev
## eslint配置文件
    "ecmaFeatures": { // ecmaFeatures指定你想使用哪些额外的语言特性
        "jsx": true //启动JSX
    }
    "parser": "babel-eslint"
    "plugins": [ // EsLint允许使用第三方插件
      "react"
    ],
    extends: [ 
        ["eslint:recommended", "plugin:react/recommended"]
      ],

# webpack中use的顺序是倒叙的

    rules: [
      {
        test: /\.js$/,
        /*
        use指定该文件的loader, 值可以是字符串或者数组.
        这里先使用eslint-loader处理, 返回的结果交给babel-loader处理. loader的处理顺序是从最后一个到第一个.
        eslint-loader用来检查代码, 如果有错误, 编译的时候会报错.
        babel-loader用来编译js文件.
        */
        use: ['babel-loader', 'eslint-loader']
      },
