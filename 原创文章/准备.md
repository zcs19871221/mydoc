# 自我介绍

## 大纲

    毕业 - 中心 - linux 运维，java 后端 - 网易 - node.js react 单页 ci 工具 管理
    优点 - 自学，自我驱动力（工作中对工作内容不断思考并想出改进方法并实现）
    举例子 - 毕业 - Linux 运维 - 要求 just 照着文档输命令 - 但是 linux 自学，写脚本 -
    网易 - 单页应用 - 公司无框架，无代码规范，无流程规范 - react 自学，写 ci 工具

    我叫张成思，10年本科毕业。毕业后在中国专利信息中心工作，做linux相关的运维，java的后端开发。16年去了网易一直到现在，做node.Js渲染服务开发,单页应用开发，前端ci工具开发，还负责一个小组的管理。我的优点是很强的自学能力以及自我驱动力-在工作中的表现就是经常思考自己的工作内容，想出改善方法并实现。举个例子，刚毕业时我接收一个第三方公司的图像检索系统运维，主要工作就是对图像数据做预处理，当时给了我10几页的操作手册，在不同的服务器上登录，输入各种命令或执行脚本。敲了两次命令后我就开始自学linux，当时看的是鸟哥的linux私房菜，把整本书都看了，然后我开始梳理这些文档的流程，后来就写了一个自动化脚本来处理这些工作。另外就是我17年在网易接触react单页应用，自学了react，搭建了webpack脚手架。已经可以正常开发，发布项目，但是我总觉着有效率不够高，不满意的地方，于是后来我自己写了一个工具来new一个集成好的最佳配置的新项目，来统一规范，提高效率。

# 项目介绍

## 准备点

1.  简介 - 背景，做了啥（尽量粗，让他们问）
2.  难点、重点
3.  如何优化、改进
4.  涉及知识点

## 自动工具

### 简介

- 背景

  自主开发，对现有工具和效率不满意 - 公司无框架、流程、规范。

- 做了什么

  一键创建新项目，新项目集成了 ci 和最佳实现的代码。

### 难点，重点

架构设计
相比于现有的产品，我的特定就是大而全。涉及内容非常多，
创建项目的，打包部署，样本代码的，提高效率的 nodeJs 脚本等等。。
功能多，就容易把各种东西耦合在一起，

如何将代码解耦，还能灵活配置及修改就是难点，

我的做法是按照功能和流程拆分代码，
功能拆分为：创建器代码 - 持续集成代码 - 样本代码
持续集成代码按照业务拆分为：开发环境 - 生产环境
业务之间做到隔离，可独立使用，修改也不会影响其他。
然后每个业务又按照工作流程进行拆分，把每个流程的功能点都拆分出来，
通过组合实现代码的复用。（比如开发环境拆分成 server 部分，打包编译，版本控制，生产环境分为打包编译，版本控制，上传，部署服务器，可以把公用的打包编译拆出来）

### 优化、改进

对创建代码进行优化，做成类似于 yeoman 这样支持对生成项目进行定制的形式。

### 知识点

- node.js
- webpack

流程：
文件处理  
js:  
loader: eslint -> babel  
css  
loader: less -> styleLint(postcss) —> autoPrefixer(postcss) -> css loader(解析依赖) -> css 聚合  
img  
url-loader(处理图片 base64)  
非 js,html,json  
file-loader  
优化：  
代码分割  
优化压缩  
service worker  
预渲染模式  
帮助:  
快捷路径 - webpack resolve  
注入后端参数 - DefinePlugin  
html 模板 - htmlPlugin

0.  webpack 的 scope hoist？

        默认的打包结构是
        (function() {
        // 1. 模块缓存对象
        // 2. 注入函数，提供内置方法
        // 比如热加载，webpackrequire 和 import 方法
        // 3. 执行 require(0)() 0 就是入口 js 文件 id，唯一
        })({
        '模块路径': 包装源代码后的函数，提供内部方法
        })

        scope hoist 就是诸如

        const a = require('a');
        a()这样的代码，在一定条件下把 const a = require('a')替换成 a 模块中的的源代码。
        好处一个是可以减少打包体积，只摘出有用的代码，第二个减少上面结构中参数中的模块定义数量，
        减少对索引的查找，提升速度。

1.  webpack4 的 code split
    三种模式：inital(针对同步),async(针对异步),all（所有）
    切分默认条件：(从属于 node_module ||包大于 30kb )&&(import 的并行请求数小于 3)
1.  webpack 与 grunt、gulp 的不同？

    入口 vs 流（任务）

1.  与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？
    webpack,rollup,Parcel
    rollup 以性能起家，webpack 以处理大量依赖起家。
    Parcel 以好上手起家。
    现在 rollup 和 webpack 的性能基本一致。但 webpack 提供更全面的定制化。
1.  有哪些常见的 Loader？他们是解决什么问题的？
1.  有哪些常见的 Plugin？他们是解决什么问题的？
1.  Loader 和 Plugin 的不同？
1.  webpack 的构建流程是什么?从读取配置到输出文件这个过程尽量说全
1.  是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？
1.  webpack 的热更新是如何做到的？说明其原理？

    在内存中编译
    编译后页面发送请求获取最新模块
    内存中替换模块不刷新

    四部分内容：
    devServer:建立和 client 的通信，构建后发送消息，接收请求，返回内存中的打包代码
    注入 client：建立和 server 通信，接收构建消息后，调用 webpack 热替换 api，根据调用结果执行热替换或页面
    重刷
    webpack 模板中的 hotapi：比对打包结果，获取改变代码的模块，然后去对应模块中执行用户自定义代码
    自己开发模块中的响应代码：当热更新触发后，执行热更新的代码

1.  如何利用 webpack 来优化前端性能？（提高性能和体验）
    代码合并、压缩
    删除死代码 tree shaking
    按需加载
    通过配置切换前缀 cdn 或测试
    code split
1.  如何提高 webpack 的构建速度？
    缓存
    多线程
    第三方模块提出 dll
1.  怎么配置单页应用？怎么配置多页应用？
1.  npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？
1.  如何在 vue 项目中实现按需加载？

- react
- npm
- jest
- redux
- babel

## 新闻审核单页应用

### 简介

- 背景
  基于 react 的审核网易新闻内容的单页应用。
  有多条业务线，不同的系统审核，权限不好管理，效率低。
  然后我做的本来也是其中一条线的审核系统，因为审核方觉着好用，所以后续就决定把所有的业务线
  都集成到我的系统里。

### 难点，重点

架构设计。
为什么？
背景是很多业务线（子系统），权限复杂，相似的菜单，相似的界面，相似的接口但是都有不同。
比如两个不同业务线，都有审核菜单，菜单里的界面基本一样，但是某个下拉菜单数据不一样，然后某个功能需要隐藏这样。请求的接口名不一样，但是
逻辑含义和返回数据结构一致。
所以复用模块，统一管理权限和接口，将权限和组件解耦以达到快速开发。

1. 设计权限对象，每个子系统一个，包含 id 等基本信息。
2. 重新设计后端的权限数据，以前是包含角色和权限，需要按照角色和权限配置菜单，展示等，很不灵活。比如一个管理员之前绑定了两个业务线的审核菜单，现在又要添加别的业务线，我这里就要对应修改代码，而且要根据角色和权限来判断，多个数据来源容易出错。后来我设计成只传菜单相关的对象，键是菜单名，值是对应的子系统 id，然后我有一个全部的菜单树，对它遍历，根据后端数据动态生成菜单，无论后端权限怎么变，我这里都不用改。
3. 当点击菜单的时候，调用一个高阶组件，获取路由的权限对象 id 以及一些参数，根据 id 生成权限对象，
   然后我的接口模块和权限模块会根据权限对象生成这个子系统菜单对应的接口和展示配置对象，注入到我的容器型组件中。这个组件根据接口获取数据，然后根据配置对象调展示形组件来渲染页面。我的接口模块，分两部分，一个是所有接口的配置对象。每个子系统下相似的接口定义为一种，配置一个生产函数，根据权限对象生成的接口，另一个就是给每个菜单都配置包含哪些接口。
4. 容器型组件
5. 展示型组件

### 优化，改进

权限和接口可以按照子系统的模式进行拆分，减少打包体积，提速。
因为一开始没想到会有那么多的子系统加入，所以为了方便，就都放到了一个文件里。

### 知识点

## 新闻页渲染

# 算法

## 分治法

快速排序
找到一个点，使左边的都比他小，右边的都比他大
重复把数组进行左右分割，最终数组有序

    //快速排序
    const qS = (ar, l, r) => {
        if (l < r) {
            let i = l;
            let j = r;
            let p = ar[l];
            while (i < j) {
                while (ar[j] >= p && i < j) {
                    j--
                }
                ar[i] = ar[j]
                while (ar[i] <= p && i < j) {
                    i++
                }
                ar[j] = ar[i]
            }
            ar[i] = p
            qS(ar, l, i - 1);
            qS(ar, i + 1, r)
        }
    }

    //用循环和数组模拟递归和条件
    const qS = (ar, l, r) => {
        const stack = [{
            l,
            r
        }]
        while (stack.length > 0) {
            const {l, r} = stack.pop();
            if (l >= r) {
                continue;
            }
            let i = l;
            let j = r;
            let p = ar[l];
            while (i < j) {
                while (ar[j] >= p && i < j) {
                    j--
                }
                ar[i] = ar[j]
                while (ar[i] <= p && i < j) {
                    i++
                }
                ar[j] = ar[i]
            }
            ar[i] = p
            stack.push({
                l,
                r: i - 1
            })
            stack.push({
                l: i + 1,
                r
            })
        }
    }

归并排序
寻找 k 小的元素
思路：利用快速排序，每次筛出索引 mid 点，那么 mid 点左侧都是比他小的，右侧都是比他大的，那么 k 和 mid 点比较，如果 k===mid，那么 mid 点左侧的数组就是需要的元素，直接输出。否则，将范围缩小:K > mid [mid + 1, right] k < mid [l, k - 1] 这样不需要全部排序，快速定位到点。

    const divide = (ar, l, r) => {
        if (l < r) {
            const mid = Math.floor((l + r) / 2);
            divide(ar, l, mid);
            divide(ar, mid + 1, r);
            console.log(l, mid, mid + 1, r)
            merge(ar, l, mid, mid + 1, r);
        }
    }

    function merge(ar, l1, r1, l2, r2) {
        const sorted = [];
        let i = l1;
        let j = l2;
        let k = 0;
        while (i <= r1 && j <= r2) {
            if (ar[i] <= ar[j]) {
                sorted[k++] = ar[i++]
            } else {
                sorted[k++] = ar[j++]
            }
        }
        while (i <= r1) {
            sorted[k++] = ar[i++];
        }
        while (j <= r2) {
            sorted[k++] = ar[j++];
        }
        sorted.forEach((e, i) => {
            ar[l1 + i] = e;
        })
    }

    const guibing = ar => {
        divide(ar, 0, ar.length - 1);
        return ar
    }
