# 自我介绍

## 大纲

    毕业 - 中心 - linux 运维，java 后端 - 网易 - node.js react 单页 ci 工具 管理
    优点 - 自学，自我驱动力（工作中对工作内容不断思考并想出改进方法并实现）
    举例子 - 毕业 - Linux 运维 - 要求 just 照着文档输命令 - 但是 linux 自学，写脚本 -
    网易 - 单页应用 - 公司无框架，无代码规范，无流程规范 - react 自学，写 ci 工具

    我叫张成思，10年本科毕业。毕业后在中国专利信息中心工作，做linux相关的运维，java的后端开发。16年去了网易一直到现在，做node.Js渲染服务开发,单页应用开发，前端ci工具开发，还负责一个小组的管理。我的优点是很强的自学能力以及自我驱动力-在工作中的表现就是经常思考自己的工作内容，想出改善方法并实现。举个例子，刚毕业时我接收一个第三方公司的图像检索系统运维，主要工作就是对图像数据做预处理，当时给了我10几页的操作手册，在不同的服务器上登录，输入各种命令或执行脚本。敲了两次命令后我就开始自学linux，当时看的是鸟哥的linux私房菜，把整本书都看了，然后我开始梳理这些文档的流程，后来就写了一个自动化脚本来处理这些工作。另外就是我17年在网易接触react单页应用，自学了react，搭建了webpack脚手架。已经可以正常开发，发布项目，但是我总觉着有效率不够高，不满意的地方，于是后来我自己写了一个工具来new一个集成好的最佳配置的新项目，来统一规范，提高效率。

# 项目介绍

## 准备点

1.  简介 - 背景，做了啥（尽量粗，让他们问）
2.  难点、重点
3.  如何优化、改进
4.  涉及知识点

## 自动工具

### 简介

- 背景

  自主开发，对现有工具和效率不满意 - 公司无框架、流程、规范。

- 做了什么

  一键创建新项目，新项目集成了 ci 和最佳实现的代码。

### 难点，重点

相比于现有的产品，我的特定就是大而全。涉及内容非常多，
创建项目的，打包部署，样本代码的，提高效率的 nodeJs 脚本等等。。
功能多，就容易把各种东西耦合在一起，

如何将代码解耦，还能灵活配置及修改就是难点，

我的做法是按照功能和流程拆分代码，
功能拆分为：创建器代码 - 持续集成代码 - 样本代码
持续集成代码按照业务拆分为：开发环境 - 生产环境
然后不同环境代码按照工作流程再进行拆分，把公共流程的代码提取出来，比如开发和生产都有打包和版本控制。
然后每一部分再度拆分功能成单独文件。
通过配置文件和环境变量结合的方式进行定制化，环境变量使用单独的模块进行读写。

### 优化、改进

对创建代码进行优化，做成类似于 yeoman 这样支持对生成项目进行定制的形式。

### 知识点

- node.js
- webpack

流程：
文件处理
js:
loader: eslint -> babel
css
loader: less -> styleLint(postcss) —> autoPrefixer(postcss) -> css loader(解析依赖) -> css 聚合
img
url-loader(处理图片 base64)
非 js,html,json
file-loader
优化：
代码分割
优化压缩
service worker
预渲染模式
帮助:
快捷路径 - webpack resolve
注入后端参数 - DefinePlugin
html 模板 - htmlPlugin

1. webpack 与 grunt、gulp 的不同？

   入口 vs 流（任务）

1. 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？
   webpack,rollup,Parcel
   rollup 以性能起家，webpack 以处理大量依赖起家。
   Parcel 以好上手起家。
   现在 rollup 和 webpack 的性能基本一致。但 webpack 提供更全面的定制化。
1. 有哪些常见的 Loader？他们是解决什么问题的？
1. 有哪些常见的 Plugin？他们是解决什么问题的？
1. Loader 和 Plugin 的不同？
1. webpack 的构建流程是什么?从读取配置到输出文件这个过程尽量说全
1. 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？
1. webpack 的热更新是如何做到的？说明其原理？
1. 如何利用 webpack 来优化前端性能？（提高性能和体验）
   代码合并、压缩
   删除死代码 tree shaking
   按需加载
   通过配置切换前缀 cdn 或测试
   code split
1. 如何提高 webpack 的构建速度？
   缓存
   多线程
   第三方模块提出 dll
1. 怎么配置单页应用？怎么配置多页应用？
1. npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？
1. 如何在 vue 项目中实现按需加载？

- react
- npm
- jest
- redux
- babel

# 算法
## 分治法
快速排序
找到一个点，使左边的都比他小，右边的都比他大
重复把数组进行左右分割，最终数组有序

    //快速排序
    const helper = (ar, l, r) => {
        let p = ar[l];
        let i = l, j = r;
        if (l >= r) {
            return 
        }
        while (i < j) {
            while (p > ar[i]) {i++}
            while (p < ar[j]) {j--}
            if (i < j) {
                const t = ar[j];
                ar[j] = ar[i];
                ar[i] = t;
            }
        }
        helper(ar, l, i - 1)
        helper(ar, i + 1, r)
    }

    const quickSort = ar => {
        helper(ar, 0, ar.length - 1);
        return ar;
    }

    //用循环和数组模拟递归和条件
    const quickSort = ar => {
        const stack = [{
            l: 0,
            r: ar.length - 1
        }];
        while (stack.length > 0) {
            const {l, r} = stack.pop()
                let p = ar[l];
            let i = l,
                j = r;
            while (i < j) {
                while (p > ar[i]) {i++}
                while (p < ar[j]) {j--}
                if (i < j) {
                    const t = ar[j];
                    ar[j] = ar[i];
                    ar[i] = t;
                }
            }
            if (i - 1 > l) {
                stack.push({
                    l,
                    r: i - 1
                })
            }
            if (r > i + 1) {
                stack.push({
                    l: i + 1,
                    r
                })
            }
        }
        return ar
    }


归并排序
寻找k小的元素
思路：利用快速排序，每次筛出索引mid点，那么mid点左侧都是比他小的，右侧都是比他大的，那么k和mid点比较，如果k===mid，那么mid点左侧的数组就是需要的元素，直接输出。否则，将范围缩小:K > mid [mid + 1, right] k < mid [l, k - 1] 这样不需要全部排序，快速定位到点。

    const divide = (ar, l, r) => {
        if (l < r) {
            const mid = Math.floor((l + r) / 2);
            divide(ar, l, mid);
            divide(ar, mid + 1, r);
            console.log(l, mid, mid + 1, r)
            merge(ar, l, mid, mid + 1, r);
        }
    } 

    function merge(ar, l1, r1, l2, r2) {
        const sorted = [];
        let i = l1;
        let j = l2;
        let k = 0;
        while (i <= r1 && j <= r2) {
            if (ar[i] <= ar[j]) {
                sorted[k++] = ar[i++]
            } else {
                sorted[k++] = ar[j++]
            }      
        }
        while (i <= r1) {
            sorted[k++] = ar[i++];
        }    
        while (j <= r2) {
            sorted[k++] = ar[j++];
        }
        sorted.forEach((e, i) => {
            ar[l1 + i] = e;
        })
    }

    const guibing = ar => {
        divide(ar, 0, ar.length - 1);
        return ar
    }
