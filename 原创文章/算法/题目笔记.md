# 538
binary tree 放大

按照后序遍历，把遍历的值累加，重新设置树的值即可

# 563
每个节点的左子树节点之和-右子树节点之和命名为Tilt.
求所有节点的Tilt之和。

我一开始的做法是，先写一个求sum值的函数，然后遍历树，
对每个节点调用sum函数，计算差值，求和。

这样相当于对每个节点遍历两次，sum也会重复计算。

优化方法是遍历一次，每次计算left sum值，right sum值，遍历过程中
记录差值求和，返回left+sum+root.val，减少计算sum次数

优化点，只遍历一次，sum值累加，遍历时候计算Tilt

# 671
一个二叉树，每个子树根节点是最小值，求第二小的值。
注意，如果类似 {val:2,left:2,right:2}这种没有第二小的值，返回-1

我的错误思路：
1. 计算左子树的最小值，右子树的最小值，那么这两个值的最小值就是第二小的值。
总体思路可以，但是细节不对，因为这样有可能最小值就是root节点值，把第二小值给覆盖了。然后我为了补救，就在递归左右子树时候加了额外的函数判断左右子树和根节点的关系，返回比根节点值大的最小值。然后对左子树和右子树执行辅助方法，最后还要判断一下，很冗余。

我的问题还是没有抓住关键点，一开始的思路就不对，做的很冗余

正确的思路：
1. divide and conquer。巧妙的地方在于判断子树是否和根的值一样，如果一样，对这个节点迭代，然后获取左右子树的最小值，规避了根节点同值的问题。
divide：
把问题缩小成一个树
conquer：
同值时候，递归求值。
当问题足够小时（和根节点值不同），直接返回比较结果
combine
比较左右子树的值：
如果没有-1，直接math.min
然后返回非-1的值。
最后返回剩下的值（-1）。
边界条件：
* root === null return -1
* root is node(left=null,right=null) return -1
2. 单纯的遍历
但是思路是根节点就是最小的，只要不和最顶层根节点相等，就是这个子树里最小值，然后递归所有子树获取最小值

# 101
判断树是否是镜像

我的思路：先序遍历左树，每个节点累加字符串得一个结果，然后后续遍历右子树，节点累加字符串，最终比较字符串是否相等。
这个思路不能说不对，但是比较冗余，而且需要把树全部遍历才能获得结果

正确思路：
1. 递归。一次传入两个节点，根据是否为空，值是否相等来判断是否镜像，如果判断不出来，接着递归判断左子树的左节点和右子树的右节点。这样的优点就是减少无谓的递归，快速获得节点，非常简洁。


# 437
寻找一个树中路径(从某节点开始向下到某节点结束)之和为指定值的个数。

我的思路：遍历节点时候，记录当前这个节点所有累加值5->6对应[5,6 + 5]，
下一个节点时候，这个数组每个值加当前节点，然后判断是否有sum。每个节点都需要遍历一遍暂存的数组，非常慢。

正确思路：
hashMap记录,key是累加值，value是这个累加值出现的次数。

那么如果map[当前累加 - 目标值] = 某次累加 存在，那么表示存在连续值想加等于目标值。举例：
i0 + i1 + i2 + i3 - target = i0 || i0 + i1 || i0 + i1 + i2
那么target = i1 + i2 + i3||i2 + i3||i3
而且每当保存map[累加值] = map[累加值] || 0 + 1;
然后总值等于左右节点递归想加
当操作完左右节点后，把map[累加值] - 1作为回退处理，很巧妙

# 111
求子树的最小深度。

题目不难，深度优先和广度优先均可。

深度优先

我的思路是：每次递归子树时候，传递父子树的深度，接收后深度+1传给子树，然后Min左右子树。

答案的思路是：不传递深度，每次递归结束返回深度值+1,减少额外的存储空间。
