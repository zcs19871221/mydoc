# 538
binary tree 放大

按照后序遍历，把遍历的值累加，重新设置树的值即可

# 563
每个节点的左子树节点之和-右子树节点之和命名为Tilt.
求所有节点的Tilt之和。

我一开始的做法是，先写一个求sum值的函数，然后遍历树，
对每个节点调用sum函数，计算差值，求和。

这样相当于对每个节点遍历两次，sum也会重复计算。

优化方法是遍历一次，每次计算left sum值，right sum值，遍历过程中
记录差值求和，返回left+sum+root.val，减少计算sum次数

优化点，只遍历一次，sum值累加，遍历时候计算Tilt

# 671
一个二叉树，每个子树根节点是最小值，求第二小的值。
注意，如果类似 {val:2,left:2,right:2}这种没有第二小的值，返回-1

我的错误思路：
1. 计算左子树的最小值，右子树的最小值，那么这两个值的最小值就是第二小的值。
总体思路可以，但是细节不对，因为这样有可能最小值就是root节点值，把第二小值给覆盖了。然后我为了补救，就在递归左右子树时候加了额外的函数判断左右子树和根节点的关系，返回比根节点值大的最小值。然后对左子树和右子树执行辅助方法，最后还要判断一下，很冗余。

我的问题还是没有抓住关键点，一开始的思路就不对，做的很冗余

正确的思路：
1. divide and conquer。巧妙的地方在于判断子树是否和根的值一样，如果一样，对这个节点迭代，然后获取左右子树的最小值，规避了根节点同值的问题。
divide：
把问题缩小成一个树
conquer：
同值时候，递归求值。
当问题足够小时（和根节点值不同），直接返回比较结果
combine
比较左右子树的值：
如果没有-1，直接math.min
然后返回非-1的值。
最后返回剩下的值（-1）。
边界条件：
* root === null return -1
* root is node(left=null,right=null) return -1
2. 单纯的遍历
但是思路是根节点就是最小的，只要不和最顶层根节点相等，就是这个子树里最小值，然后递归所有子树获取最小值

