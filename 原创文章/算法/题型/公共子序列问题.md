# 712 

关键点：
s[i] === s[j]，那么可以删去，因为这俩肯定是公共序列。不用计算。
dp[i][j] = s[i] === s[j] ? dp[i - 1][j - 1] : (dp[i - 1][j] + charCode(i - 1), dp[i][j - 1] + charCode(j - 1), dp[i - 1][j - 1] + charCode(i- 1) + charCode(j - 1))

其中dp[i - 1][j - 1] + charCode(i- 1) + charCode(j - 1))是冗余的，因为在求dp[i - 1][j]的时候，会比较dp[i - 1][j - 1]


# 1143

思路和712基本一致，优化点：空间优化，因为只使用了dp的上一行，所以dp的行可以设置成2，使用i % 2映射到这两行就好。

1092

1062 

# 516
回文：
dp[i][j] = s[i] === s[j] ? 2 + dp[i + 1][j - 1]:  max(dp[i + 1][j],dp[i][j - 1]


总结：
1. 查看s[i] === s[j]
2. 和dp[i + 1][j] dp[i][j - 1]关系


# 583

几乎和712一样