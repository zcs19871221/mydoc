# 求树的深度
1. 深度优先 - 获取每个子树深度，比较每个子树的最大值
2. 广度优先 - 记录队列长度，长度等同于层的节点数，每个节点出队，同时每个节点的子树 
入队。关键点，尾入头出 push - shift

# 循环实现先序遍历

第一步：
    一路向左入栈
第二部：
    当栈非空时候，出栈，查看是否有右子树，
    如果有，入栈。然后看是否有左子树，入栈

    root = root.right
    while (root) {
        stack.push(root);
        root = root.left;
    }

    const stack = []; 
    let index = 0
    while (root) {
        stack.push(root)
        root = root.left;
    }
    while (stack.length) {
        root = stack.pop();
        if (++index === k) {
            return root.val;
        }
        root = root.right
        while (root) {
            stack.push(root);
            root = root.left;
        }
    }