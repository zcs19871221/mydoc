# 通用法
1. 参数判断
# 数据结构
* 树
    1. 递归注意结束条件，一般的条件和特殊点的结束条件
    2. 如果有返回值，保持类型一致。



# 树如何做
1. 一般套路是bfs、dfs、使用堆栈先序遍历、构建树。
2. 如果dfs
    1. 先确定是先序，中序还是后序。
    2. 确定递归返回值。
    3. 是否需要全局变量，比如prev，acc之类的辅助。
3. 如果bfs，一般和层级关系明显
    1. 两种
        1. 给定具体层级，比如第xx层要做什么操作。保存const size = stack.length;一次处理一层。
        2. 无明显层级，顺着遍历，在while条件上做文章。比如判断最后一层子树是否都在最左侧，while判断条件使用stack[0] !== null，找到最后一层第一个null节点，然后把stack头部的null出队列，最后判断是否队列为空
4. 堆栈先序遍历:一般用于binary search tree。按照先序遍历。
    1. 判断条件：非空栈或者root非空
    2. 一路向左遍历且入栈：while(root !== null) {stack.push(root);root= root.left}
    3. root从stack中出栈获取： root = stack.pop();
    4. 对root做操作，比如记录第一个或者其他的。
    5. root变成右子树：root = root.right;
5. 从数组构建树：
    1. 通用方法，设置start和end 指针。然后找到root，然后递归缩小left和right子树。
    2. binary search tree：递归过程中传递极值：root.left = helper(min, root.val); root.right = helper(root.val, max);
6. binary search 树：
    1. 先序队列遍历，比较前一个值。
    2. 递归时候，设置min和max值，替换left && right

# 如果没思路不会做怎么办
0. 先仔细读题，了解题目意思，尝试用不同的套路方法
1. 上一步没做出来，用暴力破解方法实现
2. 仔细观察，看能否优化，一般通过hash，hash包括正向和反向：hash[target - value]
