# 通用法
1. 参数判断
# 数据结构
* 树
    1. 递归注意结束条件，一般的条件和特殊点的结束条件
    2. 如果有返回值，保持类型一致。
* 有序数组
    1. 寻找某个值
    binary search 给定一个开始和结束点，然后比对中间点和目标值，把中间点作为
    起始点或结束点缩小查找范围来寻找
    2. two sum
        - 两指针法 - 一个在开始，一个在结束，两个位置值求和和sum值比较，然后  
        对应移动开始或结束指针，直到两个指针重合

# 题型
* two sum(给一个数组或树，给一个值k，求是否数组或书中存在两个加起来是k的值)
    1. hash法 - 遍历所有元素，保存在hash中。遍历值x时候，看是否存在map[k - x]
    2. 针对有序数组（binarytree先序遍历获取）使用two point法 - 一个在开始，一个在结束，两个位置值求和和sum值比较，然后  
        对应移动开始或结束指针，直到两个指针重合
    3. binary search法：针对有序数组或树，对每一个遍历元素进行binarysearch。
    4. 为了节省空间，考虑不暂存累加值，而是把sum - 当前值作为参数传递，减少累加值的存储
# 算法
1. binary search
    题型：two sum
    数据结构：有序数组或binary tree
2. two points
    数据结构：数组，有序数组（两边指针向中间靠拢）
    题型：two sum when 有序数组
3. hash
    题型：two sum

# 如何选择图算法
union find：如果图上的节点之间关系很明显，可使用。直接union关联节点。

dfs：遍历所有节点，设置visited。每一个节点遍历，通过这个节点能够爬到相邻接点。关键点在于如何相邻节点，这个关系是否明晰。

unionfind 不用遍历整个图，只要union关联节点。联通数量为n-(连通数)

dfs 需要遍历整个图，联通数量为 所有非传递遍历数量。

核心是选择哪个作为图的节点，节点之间通过什么关系连接。

# 树如何做
1. 一般套路是bfs、dfs、还有使用堆栈先序遍历。
2. 如果dfs
    1. 先确定是先序，中序还是后序。
    2. 确定递归返回值。
    3. 是否需要全局变量，比如prev，acc之类的辅助。
3. 如果bfs，一般和层级关系明显
    1. 两种
        1. 给定具体层级，比如第xx层要做什么操作。保存const size = stack.length;一次处理一层。
        2. 无明显层级，顺着遍历，在while条件上做文章。比如判断最后一层子树是否都在最左侧，while判断条件使用stack[0] !== null，找到最后一层第一个null节点，然后把stack头部的null出队列，最后判断是否队列为空
4. 堆栈先序遍历:一般用于binary search tree。按照先序遍历。
    1. 判断条件：非空栈或者root非空
    2. 一路向左遍历且入栈：while(root !== null) {stack.push(root);root= root.left}
    3. root从stack中出栈获取： root = stack.pop();
    4. 对root做操作，比如记录第一个或者其他的。
    5. root变成右子树：root = root.right;
# 如果没思路不会做怎么办
0. 先仔细读题，了解题目意思，尝试用不同的套路方法
1. 上一步没做出来，用暴力破解方法实现
2. 仔细观察，看能否优化，一般通过hash，hash包括正向和反向：hash[target - value]
