# 什么类型用到图？
求两点是否连通。
求连通区域个数。
寻找路径。

# 如何做图？
1. 确定哪些是图的点。
2. 找出点之间的关系，也就是边。
3. 构建图：
    邻接表或者
    unionFind或者
    dfs搜索


# 数据结构：
1. 邻接表

    a -> [b,c,d]
    b -> [a]
    c -> [a]
    d -> [a]


# union find

    const count = allNodeCount;
    const id = [];
    const find = p => {
        if (!p) {
            id[p] = p;
        }
        if (id[p] !== p) {
            // 减少树高度，全部指向root，比如目前有树：a->b->c d->a 现在
            //查找d，递归查找到最后，变成 d->c a->c b->c 的c为根，三个子树，深度为1.
            id[p] = find(id[p])
        }
        return id[p];
    }
    const union = (p, q) => {
        const a = find(p);
        const b = find(q);
        if (a === b) {
            return
        }
        // 根指向另一个根，再优化就是sz权重，记录根的数量
        // 因为find已经优化了树的深度，所以没必要
        id[a] = b;
        // 连通个数-1
        count--;
    }

适用于：求连通性：
    1. 两点是否相连
        find(a) === find(b)
    2. 连通个数。
        return count;


# dfs
    let count = 0;
    const visited = {};
    const g = {a:[b,c],b:[a], c: [a]}
    const dfs = node => {
        visited[node] = true;
        for (const adj of g.adj(node) /** g[node]**/) {
            if (!visitd[node]) {
                dfs(adj);
            }
        }
    }
    const queryAll = () => {
        for (let i = 0; i < g.allNodes(); i++) {
            if (!visited[g.allNodes[i]]) {
                dfs(g.allNodes[i])
                count++;
            }
        }
    }
    
求连通性：
    1. 两点是否相连。
        TODO
    2. 连通个数。
        return count;
寻找路径：
    TODO


