# 什么题目用到？
求两点是否连通。
求连通区域个数。
寻找路径。

# 如何做？
1. 确定哪些是点。
2. 找出点之间的关系(也就是边)。
3. 套用模板构建图：邻接表 || unionFind || dfs
4. 根据不同算法特性辅助


## unionFind
适用性（优先级从高到低）
1. 两点是否相连 
    find(a) === find(b)
2. 寻找令图闭合的边。(find(a) === find(b))
3. 连通个数。


## dfs
适用性（优先级从高到低）
1. 寻找点到点的路径：
    遍历，当当前节点和目标节点相等，结束。
2. 求连通性
    1. 两点是否相连。
        能否遍历到
    2. 连通个数。
        return count;


## 题目
1. 399 求两点之间的路径，并累加路径中间的计算值。
2. 684 去掉冗余边保证剩余点都连通 - 思路逆转，就是找到一个边，当这个边有的时候，整个图是闭合的。也就是当union到一对边的时候，find(p) === find(q)，表示这个图闭合了。
3. 947 删除石头。- 问题转换成求连通图个数。技巧1：把一个坐标点转变成两个点，union免去查找同行和同列 技巧2：count在id === undefined的时候+1，自动计算节点总数。

# 模板
## 邻接表

    a -> [b,c,d]
    b -> [a]
    c -> [a]
    d -> [a]


## union find

    const count = allNodeCount;
    const id = [];
    const find = p => {
        if (!p) {
            id[p] = p;
        }
        if (id[p] !== p) {
            // 减少树高度，全部指向root，比如目前有树：a->b->c d->a 现在
            //查找d，递归查找到最后，变成 d->c a->c b->c 的c为根，三个子树，深度为1.
            id[p] = find(id[p])
        }
        return id[p];
    }
    const union = (p, q) => {
        const a = find(p);
        const b = find(q);
        if (a === b) {
            return
        }
        // 根指向另一个根，再优化就是sz权重，记录根的数量
        // 因为find已经优化了树的深度，所以没必要
        id[a] = b;
        // 连通个数-1
        count--;
    }

## dfs遍历
    let count = 0;
    const visited = {};
    const g = {a:[b,c],b:[a], c: [a]}
    const dfs = node => {
        visited[node] = true;
        for (const adj of g.adj(node) /** g[node]**/) {
            if (!visitd[node]) {
                dfs(adj);
            }
        }
    }
    const queryAll = () => {
        for (let i = 0; i < g.allNodes(); i++) {
            if (!visited[g.allNodes[i]]) {
                dfs(g.allNodes[i])
                count++;
            }
        }
    }





