# 通解
s[i] === s[j]，从而比较dp[i - 1][j - 1] 
就是两个字串删除这辆相等的，比较

s[i] !== s[j]，从而比较dp[i][j - 1] dp[i - 1][j]
删除字串1末尾和字串2比较。或删除字串2末尾和字串1比较
# 712 

dp[i][j]代表序列1以i结束和序列2以j结束的两个字符串的公共子序列最大长度

关键点：
s[i] === s[j]，那么可以删去，因为这俩肯定是公共序列。不用计算。
dp[i][j] = s[i] === s[j] ? dp[i - 1][j - 1] : (dp[i - 1][j] + charCode(i - 1), dp[i][j - 1] + charCode(j - 1), dp[i - 1][j - 1] + charCode(i- 1) + charCode(j - 1))

其中dp[i - 1][j - 1] + charCode(i- 1) + charCode(j - 1))是冗余的，因为在求dp[i - 1][j]的时候，会比较dp[i - 1][j - 1]


# 1143

思路和712基本一致，优化点：空间优化，因为只使用了dp的上一行，所以dp的行可以设置成2，使用i % 2映射到这两行就好。


# 516
回文：
dp[i][j] = s[i] === s[j] ? 2 + dp[i + 1][j - 1]:  max(dp[i + 1][j],dp[i][j - 1]


总结：
1. 查看s[i] === s[j]
2. 和dp[i + 1][j] dp[i][j - 1]关系


# 583

几乎和712一样