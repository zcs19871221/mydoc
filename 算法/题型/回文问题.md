# 647

求回文数量

1. 暴力搜索：`n*n*n`

从i,j=i+1遍历，搜索[i,j]是否回文,while(i++==j--) {}

2. 字符拓展
从i[0,n]遍历,从[i,i]和[i, i+1]（对应奇数和偶数）向两边拓展，如果满足s[i]===s[j]，才继续拓展，
时间复杂度 n * n，搜索回文时不重复搜索。

3. 动态规划

dp[i][j]代表从i到j的字符是回文。
那么dp[i][j]是回文的条件是，dp[i + 1][j - 1]是回文，且s[i] === s[j]
另外dp[i + 1][j - 1]在s[i] === s[j]的情况下可以避过这几个情况：
a 单字符，是回文
aa 双字符，是回文
axa 三字符，只要s[i]===s[j]，x是什么无所谓

dp[i][j] = s[i] === s[j] && (j - i < 3 && dp[i + 1][j - 1])

## 所以核心就是回文条件是头尾相等且dp[i+1][j-1]是回文，方法2和3都是围绕这个原则

# 516

dp[i][j] = s[i] === s[j] ? dp[i + 1][j - 1] + 2 : Math.max(dp[i, j - 1], dp[i + 1][j])

我为啥没做出来？
1. 没有明确定义dp数组的含义
2. 没有明确使用归纳的方法：从已知的结果推出未知的部分，这样定义容易归纳，容易发现状态转移关系。

下次做，分析题目后，定义dp数组含义，然后根据已知（dp[i]([j])..dp[n - 1]([m - 1])）推导出dp[n]的关系。



**当做已经知道d[1]~​dp[n - 1]的值，然后想办法利用它们求得dp[n]**​

