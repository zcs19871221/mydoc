[原文地址](http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html)

# TCP KEEPALIVE概述
　　想弄明白什么是TCP KEEPALVIE，你只需要读它的名字就好了：保持TCP连接存活。它保证你能够检查你的套接字连接（也叫TCP连接），并判断这个连接是否还存在并可以使用或者这个连接已经损坏。

## 1.什么是TCP连接
　　KEEPALIVE的概念十分简单：当你建立一个TCP连接，你就分配了一套计时器。其中一些计时器就用来处理keepalive程序。当这个keepalvie计时器到达0，你给你的交互方发送一个keepalive嗅探包，这个包没有数据，只有一个开启的ACK标识符。(因为tcp/ip协议的标准，是一个面向流的标准，这个嗅探包是一种duplicate ack包，并且不会对远端终点造成影响。You can do this because of the TCP/IP specifications, as a sort of duplicate ACK, and the remote endpoint will have no arguments, as TCP is a stream-oriented protocol.)另一方面，你将从远端主机收到一个返回，也是没有数据只有一个ack标识。

　　如果你收到一个针对你嗅探包的返回，就可以断言这个连接仍然存在并正在使用，而你就无须担心用户层去实现。实际上，TCP允许你处理流，而不是数据包，因此一个0长度的数据包对于用户程序来说是没有危险的。

　　这个程序很有用因为如果另一端断开连接（比如重启）你就会及时发现连接已经损坏了，即使你在这个连接上没有传输流量。如果你的另一端没有回复你的keepalive嗅探包，你可以断言这个连接失效，并且采取正确的措施。

## 2. 为什么使用TCP KEEPALIVE
　　没有keepalive，你的程序也可以跑得很happy。因此如果你正在读这篇文章，你应该试着去了解对于你的问题来说，keepalive是否是一个可行的解决方案。
　　Keepalive是非侵入性的，并且在大部分情况下，如果你不确定是否要使用，你可以使用它而没有什么出错的风险（我的node程序就错了）。但是请记住他会产生额外的网络流量，会对你的路由和防火墙有影响。
　　简而言之，动脑筋并且小心使用。
　　下一段落我们将会区分keepalive的两个任务目标：
* 检查死亡的端点
* 防止因为网络不活跃而断开连接
## 3. 检查死亡的端点
　　keepalive可以在你的另一端来不及通知你就挂掉了的情况下向你报告对方挂掉了的情况。这种突然挂掉的情况有几种原因，比如内核崩溃或者野蛮的关闭进程。另一种你需要keepalive探测的情景是你的对端存活但是你和对端的网络不通。在网络不通的情况下，就相当于你的对端死了。在网络不通的情况下，普通tcp操作无法检测出当前的连接状态。
　　考虑一个在A和B之间的简单的TCP连接：初始化三次握手，一个SYN片从A发往B，B返回一个SYN/ACK，最终A发一个ACK给B。在这时，我们进入到了一个稳定的状态：连接已经建立，现在我们可以普通的等待某人通过这个通道发送数据。现在问题来了：突然拔掉B的电源，B立刻就停了，没有通过这个通道发送任何东西给A告诉A这个连接已经断了。而A还在等待接收数据，并且根本不知道B已经挂了。现在恢复B的电源并重启系统。现在A和B都在线，但是A认为和B的连接仍然存在，而B不知道。这种情况下连接自己解决的方式是当A尝试给B通过死掉的通道发送数据的时候，B返回一个RST包，A收到这个RST包时候把连接关闭。
　　Keepalive能够告诉你什么时候另一端变的不可到达而没有误认为对方可用但实际不可用的风险。如果是网络出现了问题，keepalive操作会等待一些时间并重试发送嗅探包，然后把这个连接标记为不可用。

## 4. 防止因为网络不活跃而断开连接
　　另一个有用的目标是防止因为不活跃而断开连接。这是一个非常常见的问题，当你在一个NAT代理或者防火墙的后面，有可能毫无原因的断开连接。这个行为是防火墙或者代理的连接跟踪程序造成的，所有穿越防火墙或代理的连接都要被这些程序跟踪。出于这些防火墙或代理服务器机器物理上的限制，他们只能保持有限数量的连接在内存里。最常见的策略是保持最新的连接并优先舍弃老的和不活跃的连接。
　　返回到A和B的连接上。一旦A和B的连接打开，直到两端有一端发生发送的事件，才开始发生数据交互。如果很久都没有触发发送数据的事件的话，代理会把连接关闭，导致连接被断开。
　　因此定时的通过这个网络连接发送一些包会让让防火墙或代理不容易删除。（因为这个连接有数据传输，所有这个连接被删除的权重就低）也就是通过keepalive嗅探包。

